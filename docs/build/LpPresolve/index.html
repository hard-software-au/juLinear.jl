<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>LpPresolve · juLinear.jl documentation</title><meta name="title" content="LpPresolve · juLinear.jl documentation"/><meta property="og:title" content="LpPresolve · juLinear.jl documentation"/><meta property="twitter:title" content="LpPresolve · juLinear.jl documentation"/><meta name="description" content="Documentation for juLinear.jl documentation."/><meta property="og:description" content="Documentation for juLinear.jl documentation."/><meta property="twitter:description" content="Documentation for juLinear.jl documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">juLinear.jl documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href><code>LpPresolve</code></a><ul class="internal"><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li></ul></li><li><a class="tocitem" href="../LpProblem/"><code>LpProblem</code></a></li><li><a class="tocitem" href="../LpReadMPS/"><code>LpReadMPS</code></a></li><li><a class="tocitem" href="../LpReadLP/"><code>LpReadLP</code></a></li><li><a class="tocitem" href="../LpRevisedSimplex/"><code>LpRevisedSimplex</code></a></li><li><a class="tocitem" href="../LpStandardFormConverter/"><code>LpStandardFormConverter</code></a></li><li><a class="tocitem" href="../juLinear/"><code>juLinear</code></a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href><code>LpPresolve</code></a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href><code>LpPresolve</code></a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/hard-software-au/juLinear.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/hard-software-au/juLinear.jl/blob/master/docs/src/LpPresolve.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="LpPresolve-Module"><a class="docs-heading-anchor" href="#LpPresolve-Module">LpPresolve Module</a><a id="LpPresolve-Module-1"></a><a class="docs-heading-anchor-permalink" href="#LpPresolve-Module" title="Permalink"></a></h1><p>The <code>LpPresolve</code> module provides several utility functions for preprocessing linear programming problems by removing redundant rows, columns, and detecting linearly dependent constraints.</p><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><h3 id="lp_remove_zero_rows"><a class="docs-heading-anchor" href="#lp_remove_zero_rows"><code>lp_remove_zero_rows</code></a><a id="lp_remove_zero_rows-1"></a><a class="docs-heading-anchor-permalink" href="#lp_remove_zero_rows" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.LpPresolve.lp_remove_zero_rows" href="#Main.LpPresolve.lp_remove_zero_rows"><code>Main.LpPresolve.lp_remove_zero_rows</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>lp<em>remove</em>zero<em>rows(preprocessed</em>problem::PreprocessedLPProblem; ε::Float64 = 1e-8, verbose::Bool = false)</p><p>Removes zero rows (constraints) from the LP problem where all coefficients are approximately zero. This simplifies the problem by eliminating redundant constraints that do not affect the feasible region.</p><p><strong>Parameters</strong></p><ul><li><code>preprocessed_problem::PreprocessedLPProblem</code>: The LP or MIP problem to process.</li><li><code>ε::Float64 = 1e-8</code>: Tolerance used to determine if a coefficient is considered zero.</li><li><code>verbose::Bool = false</code>: If <code>true</code>, prints detailed debug information during processing.</li></ul><p><strong>Returns</strong></p><ul><li><code>PreprocessedLPProblem</code>: A new <code>PreprocessedLPProblem</code> instance with:<ul><li><code>reduced_problem</code>: Updated by removing zero rows.</li><li><code>removed_rows</code>: Updated to include indices of the removed rows.</li><li><code>is_infeasible</code>: Set to <code>true</code> if an infeasibility is detected due to a zero row with a conflicting right-hand side.</li></ul></li></ul><p><strong>Behavior</strong></p><ol><li><strong>Zero Row Detection</strong>: Identifies constraints where all coefficients in <code>A</code> are approximately zero within the tolerance <code>ε</code>.</li><li><strong>Infeasibility Check</strong>: For zero rows corresponding to equality constraints with a non-zero right-hand side (<code>b</code>), the problem is marked as infeasible.</li><li><strong>Problem Reduction</strong>: Creates a new <code>reduced_problem</code> without the zero rows, adjusting:<ul><li>Constraint matrix (<code>A</code>).</li><li>Right-hand side vector (<code>b</code>).</li><li>Constraint types (<code>constraint_types</code>).</li></ul></li><li><strong>Variables Unchanged</strong>: Variable-related data (<code>c</code>, <code>l</code>, <code>u</code>, <code>vars</code>, <code>variable_types</code>) remain unchanged.</li></ol><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">using SparseArrays

# Define the original LP problem
c = [1.0, 2.0]  # Objective function coefficients
A = sparse([0.0 0.0; 1.0 -1.0])  # Constraint matrix with a zero row
b = [0.0, 5.0]  # Right-hand side vector
l = [0.0, 0.0]  # Lower bounds
u = [Inf, Inf]  # Upper bounds
vars = [&quot;x1&quot;, &quot;x2&quot;]  # Variable names
constraint_types = [&#39;E&#39;, &#39;L&#39;]  # Constraint types (&#39;E&#39; for =, &#39;L&#39; for ≤)
variable_types = [:continuous, :continuous]  # Variable types

# Create the original LPProblem
original_lp = LPProblem(
    is_minimize = true,
    c = c,
    A = A,
    b = b,
    constraint_types = constraint_types,
    l = l,
    u = u,
    vars = vars,
    variable_types = variable_types
)

# Initialize the PreprocessedLPProblem
lp_model = PreprocessedLPProblem(
    original_problem = original_lp,
    reduced_problem = original_lp,  # Initially the same as the original
    removed_rows = Int[],           # No rows removed yet
    removed_cols = Int[],           # No columns removed yet
    row_ratios = Dict{Int, Tuple{Int, Float64}}(),  # No row reductions yet
    var_solutions = Dict{String, Float64}(),        # Variable solutions not yet filled
    row_scaling = Float64[],                        # No row scaling applied
    col_scaling = Float64[],                        # No column scaling applied
    is_infeasible = false                           # Problem is feasible initially
)

# Remove zero rows
new_lp_model = lp_remove_zero_rows(lp_model; verbose = true)

# Output the reduced problem
println(&quot;Reduced Problem after removing zero rows:&quot;)
println(new_lp_model.reduced_problem)

# Check for infeasibility
if new_lp_model.is_infeasible
    println(&quot;The problem is infeasible due to a zero row with a conflicting RHS.&quot;)
else
    println(&quot;Zero rows successfully removed.&quot;)
end</code></pre><p><strong>Notes</strong></p><ul><li><strong>Infeasibility Detection</strong>: If a zero row corresponds to an equality constraint with a non-zero right-hand side, the problem is infeasible.</li><li><strong>Sparse Matrix Efficiency</strong>: The function leverages sparse matrix properties for efficient computation.</li><li><strong>Integration</strong>: This function can be used as part of a presolve routine to simplify LP/MIP problems before optimization.</li></ul><p><strong>See Also</strong></p><ul><li><code>lp_detect_and_remove_fixed_variables</code></li><li><code>lp_detect_and_remove_row_singletons</code></li><li><code>lp_detect_and_remove_column_singletons</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hard-software-au/juLinear.jl/blob/dbe09b565b509832ea114739638be53ea46ad1d9/src/LpPresolve.jl#L231-L320">source</a></section></article><h3 id="lp_remove_row_singletons"><a class="docs-heading-anchor" href="#lp_remove_row_singletons"><code>lp_remove_row_singletons</code></a><a id="lp_remove_row_singletons-1"></a><a class="docs-heading-anchor-permalink" href="#lp_remove_row_singletons" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.LpPresolve.lp_remove_row_singletons" href="#Main.LpPresolve.lp_remove_row_singletons"><code>Main.LpPresolve.lp_remove_row_singletons</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>lp<em>remove</em>row<em>singletons(lp</em>model::PreprocessedLPProblem; ε::Float64 = 1e-8, verbose::Bool = false)</p><p>Identifies and processes row singletons in an LP or MIP problem. A row singleton is a constraint involving only one variable. The function adjusts variable bounds or fixes variables as appropriate, simplifies the problem, and updates the <code>PreprocessedLPProblem</code> struct.</p><p><strong>Parameters</strong></p><ul><li><code>lp_model::PreprocessedLPProblem</code>: The preprocessed LP or MIP problem before processing row singletons.</li><li><code>ε::Float64 = 1e-8</code>: Tolerance used to handle numerical precision issues.</li><li><code>verbose::Bool = false</code>: If <code>true</code>, prints detailed debug information during processing.</li></ul><p><strong>Returns</strong></p><ul><li><code>PreprocessedLPProblem</code>: A new <code>PreprocessedLPProblem</code> instance with:<ul><li><code>reduced_problem</code>: Updated by processing row singletons.</li><li><code>removed_rows</code>: Updated with indices of the removed singleton rows.</li><li><code>removed_cols</code>: Updated with indices of variables removed (if any).</li><li><code>var_solutions</code>: Updated with values of any variables fixed during processing.</li><li><code>is_infeasible</code>: Set to <code>true</code> if an infeasibility is detected.</li></ul></li></ul><p><strong>Behavior</strong></p><ol><li><strong>Row Singleton Detection</strong>: Identifies constraints involving only one variable.</li><li><strong>Processing</strong>:<ul><li>For <strong>equality constraints (&#39;E&#39;)</strong>:<ul><li>Solves for the variable and fixes its value.</li><li>Removes the variable and the constraint from the problem.</li></ul></li><li>For <strong>less-than-or-equal constraints (&#39;L&#39;)</strong>:<ul><li>Adjusts the variable&#39;s upper or lower bound depending on the coefficient.</li><li>Removes the constraint from the problem.</li></ul></li><li>For <strong>greater-than-or-equal constraints (&#39;G&#39;)</strong>:<ul><li>Adjusts the variable&#39;s lower or upper bound depending on the coefficient.</li><li>Removes the constraint from the problem.</li></ul></li></ul></li><li><strong>Infeasibility Check</strong>: If variable bounds become inconsistent after processing, the problem is marked as infeasible.</li><li><strong>Problem Reduction</strong>: Updates the constraint matrix, right-hand side vector, variable bounds, objective function, and removes processed variables and constraints.</li></ol><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">using SparseArrays

# Define the original LP problem
c = [2.0, 3.0, 1.0]
A = sparse([
    1.0  0.0  0.0;  # Singleton row involving x1
    0.0  1.0  1.0;
    0.0  0.0  1.0   # Singleton row involving x3
])
b = [5.0, 10.0, 3.0]
l = [0.0, 0.0, 0.0]
u = [Inf, Inf, Inf]
vars = [&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;]
constraint_types = [&#39;E&#39;, &#39;L&#39;, &#39;E&#39;]
variable_types = [:continuous, :continuous, :continuous]

# Create the original LPProblem
original_lp = LPProblem(
    is_minimize = true,
    c = c,
    A = A,
    b = b,
    constraint_types = constraint_types,
    l = l,
    u = u,
    vars = vars,
    variable_types = variable_types
)

# Initialize the PreprocessedLPProblem
lp_model = PreprocessedLPProblem(
    original_problem = original_lp,
    reduced_problem = original_lp,  # Initially the same as the original
    removed_rows = Int[],           # No rows removed yet
    removed_cols = Int[],           # No columns removed yet
    row_ratios = Dict{Int, Tuple{Int, Float64}}(),  # No row reductions yet
    var_solutions = Dict{String, Float64}(),        # Variable solutions not yet filled
    row_scaling = Float64[],                        # No row scaling applied
    col_scaling = Float64[],                        # No column scaling applied
    is_infeasible = false                           # Problem is feasible initially
)

# Process row singletons
new_lp_model = lp_remove_row_singletons(lp_model; verbose = true)

# Output the reduced problem
println(&quot;Reduced Problem after processing row singletons:&quot;)
println(new_lp_model.reduced_problem)

# Output fixed variable solutions
println(&quot;Fixed Variable Solutions:&quot;)
println(new_lp_model.var_solutions)</code></pre><p><strong>Notes</strong></p><ul><li><strong>Infeasibility Detection</strong>: If variable bounds conflict after processing, the problem is marked as infeasible.</li><li><strong>Variable Removal</strong>: Variables fixed during processing are removed from the problem.</li><li><strong>Integration</strong>: This function is part of a presolve routine to simplify LP/MIP problems before optimization.</li></ul><p><strong>See Also</strong></p><ul><li><code>lp_detect_and_remove_fixed_variables</code></li><li><code>lp_remove_zero_rows</code></li><li><code>lp_detect_and_remove_column_singletons</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hard-software-au/juLinear.jl/blob/dbe09b565b509832ea114739638be53ea46ad1d9/src/LpPresolve.jl#L429-L527">source</a></section></article><h3 id="lp_detect_and_remove_fixed_varibles"><a class="docs-heading-anchor" href="#lp_detect_and_remove_fixed_varibles"><code>lp_detect_and_remove_fixed_varibles</code></a><a id="lp_detect_and_remove_fixed_varibles-1"></a><a class="docs-heading-anchor-permalink" href="#lp_detect_and_remove_fixed_varibles" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.LpPresolve.lp_detect_and_remove_fixed_variables" href="#Main.LpPresolve.lp_detect_and_remove_fixed_variables"><code>Main.LpPresolve.lp_detect_and_remove_fixed_variables</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>lp<em>detect</em>and<em>remove</em>fixed<em>variables(lp</em>model::PreprocessedLPProblem; ε::Float64 = 1e-8, verbose::Bool = false)</p><p>Detects and removes fixed variables from an LP or MIP problem within a presolve module. A variable is considered fixed if its lower and upper bounds are approximately equal within a specified tolerance. The function removes these variables from the reduced problem and stores their values for the postsolve phase.</p><p><strong>Parameters</strong></p><ul><li><code>lp_model::PreprocessedLPProblem</code>: The preprocessed LP or MIP problem before fixed variable removal.</li><li><code>ε::Float64 = 1e-8</code>: Tolerance used to determine if a variable is fixed (i.e., when <code>|l[i] - u[i]| &lt; ε</code>).</li><li><code>verbose::Bool = false</code>: If <code>true</code>, prints detailed debug information during processing.</li></ul><p><strong>Returns</strong></p><ul><li><code>PreprocessedLPProblem</code>: A new <code>PreprocessedLPProblem</code> instance with:<ul><li><code>reduced_problem</code>: Updated by removing fixed variables and adjusting related data structures.</li><li><code>var_solutions</code>: Updated with the fixed variable values for the postsolve phase.</li><li><code>removed_cols</code>: Updated to include indices of the removed (fixed) variables.</li><li>Other fields (<code>removed_rows</code>, <code>row_ratios</code>, <code>row_scaling</code>, <code>col_scaling</code>, <code>is_infeasible</code>) remain unchanged unless affected by this operation.</li></ul></li></ul><p><strong>Behavior</strong></p><ol><li><strong>Fixed Variable Detection</strong>: Identifies variables where <code>|l[i] - u[i]| &lt; ε</code> and considers them fixed.</li><li><strong>Variable Solutions Storage</strong>: Stores the values of fixed variables in <code>var_solutions</code>.</li><li><strong>Problem Reduction</strong>: Creates a new <code>reduced_problem</code> without the fixed variables, adjusting:<ul><li>Objective function coefficients (<code>c</code>).</li><li>Constraint matrix (<code>A</code>).</li><li>Right-hand side vector (<code>b</code>).</li><li>Variable bounds (<code>l</code> and <code>u</code>).</li><li>Variable names (<code>vars</code>) and types (<code>variable_types</code>).</li></ul></li><li><strong>Constraint Adjustment</strong>: Subtracts the contributions of fixed variables from the right-hand side of constraints.</li></ol><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">using SparseArrays

# Define the original LP problem
c = [1.0, 2.0, 4.0]  # Objective function coefficients
A = sparse([1.0 -3.0 0.0; 2.0 1.0 -5.0])  # Constraint matrix
b = [10.0, 15.0]  # Right-hand side vector
l = [12.0, 0.0, 2.0]  # Lower bounds (x1 and x3 are fixed)
u = [12.0, 1.0, 2.0]  # Upper bounds
vars = [&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;]  # Variable names
constraint_types = [&#39;L&#39;, &#39;L&#39;]  # Constraint types (&#39;L&#39; for ≤)
variable_types = [:continuous, :continuous, :continuous]  # Variable types

# Create the original LPProblem
original_lp = LPProblem(
    is_minimize = false,
    c = c,
    A = A,
    b = b,
    constraint_types = constraint_types,
    l = l,
    u = u,
    vars = vars,
    variable_types = variable_types
)

# Initialize the PreprocessedLPProblem
lp_model = PreprocessedLPProblem(
    original_problem = original_lp,
    reduced_problem = original_lp,  # Initially the same as the original
    removed_rows = Int[],           # No rows removed yet
    removed_cols = Int[],           # No columns removed yet
    row_ratios = Dict{Int, Tuple{Int, Float64}}(),  # No row reductions yet
    var_solutions = Dict{String, Float64}(),        # Variable solutions not yet filled
    row_scaling = Float64[],                        # No row scaling applied
    col_scaling = Float64[],                        # No column scaling applied
    is_infeasible = false                           # Problem is feasible initially
)

# Detect and remove fixed variables
new_lp_model = lp_detect_and_remove_fixed_variables(lp_model; verbose = true)

# Output the reduced problem
println(&quot;Reduced Problem after fixed variable removal:&quot;)
println(new_lp_model.reduced_problem)

# Output the fixed variable solutions
println(&quot;Fixed Variable Solutions:&quot;)
println(new_lp_model.var_solutions)</code></pre><p><strong>Notes</strong></p><ul><li><strong>In-Place Modification</strong>: This function does not modify <code>lp_model</code> in place; it returns a new instance with updated fields.</li><li><strong>Infeasibility Check</strong>: If removing fixed variables leads to an infeasible problem, the <code>is_infeasible</code> flag is set to <code>true</code>.</li><li><strong>Integration</strong>: This function is typically used as part of a sequence of presolve operations to simplify LP/MIP problems before optimization.</li></ul><p><strong>See Also</strong></p><ul><li><code>lp_detect_and_remove_row_singletons</code></li><li><code>lp_detect_and_remove_column_singletons</code></li><li><code>lp_bound_tightening</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hard-software-au/juLinear.jl/blob/dbe09b565b509832ea114739638be53ea46ad1d9/src/LpPresolve.jl#L19-L108">source</a></section></article><h3 id="lp_remove_zero_columns"><a class="docs-heading-anchor" href="#lp_remove_zero_columns"><code>lp_remove_zero_columns</code></a><a id="lp_remove_zero_columns-1"></a><a class="docs-heading-anchor-permalink" href="#lp_remove_zero_columns" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.LpPresolve.lp_remove_zero_columns" href="#Main.LpPresolve.lp_remove_zero_columns"><code>Main.LpPresolve.lp_remove_zero_columns</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lp_remove_zero_columns(preprocessed_lp::PreprocessedLPProblem; ε::Float64=1e-8, verbose::Bool=false)</code></pre><p>Removes variables corresponding to zero columns in the constraint matrix <code>A</code> from an LP or MIP problem. Variables that do not appear in any constraints are analyzed and set to values that optimize the objective function or satisfy bounds. The function updates the <code>PreprocessedLPProblem</code> accordingly.</p><p><strong>Parameters</strong></p><ul><li><code>preprocessed_lp::PreprocessedLPProblem</code>: The preprocessed LP or MIP problem before zero column removal.</li><li><code>ε::Float64=1e-8</code>: Tolerance used to determine if a coefficient is considered zero.</li><li><code>verbose::Bool=false</code>: If <code>true</code>, prints detailed debug information during processing.</li></ul><p><strong>Returns</strong></p><ul><li><code>PreprocessedLPProblem</code>: A new <code>PreprocessedLPProblem</code> instance with:<ul><li><code>reduced_problem</code>: Updated by removing zero columns and adjusting variable values.</li><li><code>removed_cols</code>: Updated to include indices of the removed columns (variables).</li><li><code>var_solutions</code>: Updated with the values of variables corresponding to zero columns.</li><li><code>is_infeasible</code>: Set to <code>true</code> if an infeasibility is detected due to unbounded variables.</li></ul></li></ul><p><strong>Behavior</strong></p><ol><li><strong>Zero Column Detection</strong>: Identifies variables (columns) where all coefficients in <code>A</code> are approximately zero within the tolerance <code>ε</code>.</li><li><strong>Variable Processing</strong>:<ul><li>For each zero column variable, determines its value based on:<ul><li>Objective function coefficient (<code>c[j]</code>).</li><li>Variable bounds (<code>l[j]</code> and <code>u[j]</code>).</li><li>Problem type (minimization or maximization).</li></ul></li><li>Updates <code>var_solutions</code> with the variable&#39;s value.</li><li>Removes the variable from the problem.</li></ul></li><li><strong>Infeasibility Check</strong>: If a variable can improve the objective unboundedly and is unbounded in that direction, the problem is marked as infeasible.</li><li><strong>Problem Reduction</strong>: Updates the constraint matrix <code>A</code>, objective coefficients <code>c</code>, variable bounds, and other relevant data structures by removing zero columns.</li></ol><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">using SparseArrays

# Define the original LP problem
c = [1.0, -2.0, 0.0]  # Objective function coefficients
A = sparse([1.0 2.0 0.0; 0.0 -1.0 0.0])  # Constraint matrix (third column is zero)
b = [4.0, -1.0]  # Right-hand side
l = [0.0, 0.0, 0.0]  # Lower bounds
u = [Inf, Inf, Inf]  # Upper bounds
vars = [&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;]  # Variable names
constraint_types = [&#39;L&#39;, &#39;G&#39;]  # Constraint types
variable_types = [:continuous, :continuous, :continuous]  # Variable types

# Create the original LPProblem
original_lp = LPProblem(
    is_minimize = true,
    c = c,
    A = A,
    b = b,
    constraint_types = constraint_types,
    l = l,
    u = u,
    vars = vars,
    variable_types = variable_types
)

# Initialize the PreprocessedLPProblem
preprocessed_lp = PreprocessedLPProblem(
    original_problem = original_lp,
    reduced_problem = original_lp,
    removed_rows = Int[],
    removed_cols = Int[],
    row_ratios = Dict{Int, Tuple{Int, Float64}}(),
    var_solutions = Dict{String, Float64}(),
    row_scaling = Float64[],
    col_scaling = Float64[],
    is_infeasible = false
)

# Remove zero columns
new_preprocessed_lp = lp_remove_zero_columns(preprocessed_lp; verbose = true)

# Output the reduced problem
println(&quot;Reduced Problem after removing zero columns:&quot;)
println(new_preprocessed_lp.reduced_problem)

# Output variable solutions
println(&quot;Variable solutions:&quot;)
println(new_preprocessed_lp.var_solutions)</code></pre><p><strong>Notes</strong></p><ul><li><strong>Unbounded Variables</strong>: Variables with zero columns and unbounded in the direction of improving the objective function can lead to unboundedness. The problem is marked as infeasible in such cases.</li><li><strong>Integration</strong>: This function is typically used as part of a sequence of presolve operations to simplify LP/MIP problems before optimization.</li><li><strong>Variable Removal</strong>: Variables corresponding to zero columns are removed from the problem and their values are stored in <code>var_solutions</code>.</li></ul><p><strong>See Also</strong></p><ul><li><code>lp_detect_and_remove_fixed_variables</code></li><li><code>lp_remove_zero_rows</code></li><li><code>lp_remove_row_singletons</code></li><li><code>lp_detect_and_remove_column_singletons</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hard-software-au/juLinear.jl/blob/dbe09b565b509832ea114739638be53ea46ad1d9/src/LpPresolve.jl#L693-L784">source</a></section></article><h3 id="lp_remove_linearly_dependent_rows"><a class="docs-heading-anchor" href="#lp_remove_linearly_dependent_rows"><code>lp_remove_linearly_dependent_rows</code></a><a id="lp_remove_linearly_dependent_rows-1"></a><a class="docs-heading-anchor-permalink" href="#lp_remove_linearly_dependent_rows" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.LpPresolve.lp_remove_linearly_dependent_rows" href="#Main.LpPresolve.lp_remove_linearly_dependent_rows"><code>Main.LpPresolve.lp_remove_linearly_dependent_rows</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lp_remove_linearly_dependent_rows(preprocessed_lp::PreprocessedLPProblem; ε::Float64=1e-8, verbose::Bool=false)</code></pre><p>Removes linearly dependent rows from the constraint matrix <code>A</code> of the <code>PreprocessedLPProblem</code>. Detects and eliminates rows that are linear combinations of other rows.</p><p><strong>Arguments:</strong></p><ul><li><code>preprocessed_lp</code>: The <code>PreprocessedLPProblem</code> struct containing the original and reduced problem.</li><li><code>ε</code>: Threshold below which values are considered zero. Defaults to <code>1e-8</code>.</li><li><code>verbose</code>: If true, prints debugging information. Defaults to <code>false</code>.</li></ul><p><strong>Returns:</strong></p><p>A new <code>PreprocessedLPProblem</code> with linearly dependent rows removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hard-software-au/juLinear.jl/blob/dbe09b565b509832ea114739638be53ea46ad1d9/src/LpPresolve.jl#L932-L944">source</a></section></article><h3 id="presolve_lp"><a class="docs-heading-anchor" href="#presolve_lp"><code>presolve_lp</code></a><a id="presolve_lp-1"></a><a class="docs-heading-anchor-permalink" href="#presolve_lp" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.LpPresolve.presolve_lp" href="#Main.LpPresolve.presolve_lp"><code>Main.LpPresolve.presolve_lp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">presolve_lp(lp_problem::LPProblem; verbose::Bool=false)</code></pre><p>Applies presolve routines to the given <code>LPProblem</code> to reduce the problem size by removing redundant rows and columns.</p><p><strong>Arguments:</strong></p><ul><li><code>lp_problem</code>: The <code>LPProblem</code> to be presolved.</li><li><code>verbose</code>: If <code>true</code>, prints debugging information for each presolve step. Defaults to <code>false</code>.</li></ul><p><strong>Returns:</strong></p><p>A <code>PreprocessedLPProblem</code> with a reduced problem that excludes zero rows, zero columns, singleton rows, and linearly dependent rows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hard-software-au/juLinear.jl/blob/dbe09b565b509832ea114739638be53ea46ad1d9/src/LpPresolve.jl#L1035-L1046">source</a></section></article><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><p>Here’s an example of how to use the <code>lp_presolve</code> module:</p><pre><code class="language-julia hljs">using lp_presolve

# Create an LP problem (lp_problem)
preprocessed_lp = presolve_lp(lp_problem, debug=true)

# Check the results after presolve
println(&quot;Preprocessed Problem: &quot;, preprocessed_lp)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../LpProblem/"><code>LpProblem</code> »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Monday 7 October 2024 17:26">Monday 7 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
