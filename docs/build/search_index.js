var documenterSearchIndex = {"docs":
[{"location":"lp_revised_simplex/#lp_revised_simplex-Module","page":"lp_revised_simplex","title":"lp_revised_simplex Module","text":"","category":"section"},{"location":"lp_revised_simplex/","page":"lp_revised_simplex","title":"lp_revised_simplex","text":"The lp_revised_simplex module provides an implementation of the revised simplex method for solving linear programming (LP) problems.","category":"page"},{"location":"lp_revised_simplex/#Functions","page":"lp_revised_simplex","title":"Functions","text":"","category":"section"},{"location":"lp_revised_simplex/#revised_simplex","page":"lp_revised_simplex","title":"revised_simplex","text":"","category":"section"},{"location":"lp_revised_simplex/","page":"lp_revised_simplex","title":"lp_revised_simplex","text":"lp_revised_simplex.revised_simplex","category":"page"},{"location":"lp_revised_simplex/#Main.lp_revised_simplex.revised_simplex","page":"lp_revised_simplex","title":"Main.lp_revised_simplex.revised_simplex","text":"revised_simplex(lp::LPProblem) -> (solution::Vector{Float64}, optimal_value::Float64)\n\nSolves a linear programming (LP) problem using the revised simplex method. This function converts the LP problem to its standard form and iteratively finds the optimal solution by adjusting the basis variables.\n\nArguments\n\nlp::LPProblem: An LPProblem struct representing the linear programming problem to be solved. It contains the objective function, constraints, and bounds.\n\nReturns\n\nsolution::Vector{Float64}: The optimal values for the decision variables in the LP problem.\noptimal_value::Float64: The optimal objective value, calculated from the solution.\n\nMethod Overview\n\nConverts the given LP problem to its standard form (minimization, inequality constraints).\nInitializes the basis using slack variables.\nIteratively computes the basic solution by solving a system of linear equations for the current basis.\nComputes the reduced costs to determine optimality.\nSelects the entering variable (non-basic variable) and computes the direction vector.\nSelects the leaving variable (basic variable) based on the direction vector and updates the basis.\nRepeats steps 3-6 until the optimal solution is found or the problem is determined to be unbounded.\n\nNotes\n\nThe function assumes that the LP problem is bounded and feasible.\nIf unboundedness is detected, the function throws an error.\nIteration limit is set to 10 for demonstration purposes. This can be improved with a more robust termination criterion.\n\nUsage Example\n\nlp = LPProblem(\n    is_minimize = true,\n    c = [-3.0, -2.0],\n    A = sparse([1.0 2.0; 1.0 1.0]),\n    b = [4.0, 2.0],\n    l = [0.0, 0.0],\n    u = [Inf, Inf],\n    vars = [\"x1\", \"x2\"],\n    constraint_types = ['L', 'L']\n)\n\nsolution, optimal_value = revised_simplex(lp)\nprintln(\"Optimal solution: \", solution)\nprintln(\"Optimal value: \", optimal_value)\n\n\n\n\n\n","category":"function"},{"location":"lp_revised_simplex/","page":"lp_revised_simplex","title":"lp_revised_simplex","text":"The revised_simplex function solves a linear programming problem using the revised simplex method. It takes an LPProblem struct as input, converts it to standard form, and iteratively finds the optimal solution using the simplex algorithm.","category":"page"},{"location":"lp_revised_simplex/#Arguments","page":"lp_revised_simplex","title":"Arguments","text":"","category":"section"},{"location":"lp_revised_simplex/","page":"lp_revised_simplex","title":"lp_revised_simplex","text":"lp::LPProblem: An LPProblem struct representing the linear programming problem to be solved.","category":"page"},{"location":"lp_revised_simplex/#Returns","page":"lp_revised_simplex","title":"Returns","text":"","category":"section"},{"location":"lp_revised_simplex/","page":"lp_revised_simplex","title":"lp_revised_simplex","text":"solution::Vector{Float64}: The optimal values for the decision variables in the LP problem.\noptimal_value::Float64: The optimal objective value, calculated from the solution.","category":"page"},{"location":"lp_revised_simplex/#Method-Overview","page":"lp_revised_simplex","title":"Method Overview","text":"","category":"section"},{"location":"lp_revised_simplex/","page":"lp_revised_simplex","title":"lp_revised_simplex","text":"Converts the given LP problem to its standard form.\nInitializes the basis using slack variables.\nIteratively adjusts the basis, solving the LP problem.\nChecks for optimality by evaluating reduced costs.\nHandles unboundedness, if detected.\nReturns the optimal solution and objective value when found.","category":"page"},{"location":"lp_revised_simplex/#Usage-Example","page":"lp_revised_simplex","title":"Usage Example","text":"","category":"section"},{"location":"lp_revised_simplex/","page":"lp_revised_simplex","title":"lp_revised_simplex","text":"lp = LPProblem(\n    is_minimize = true,\n    c = [-3.0, -2.0],\n    A = sparse([1.0 2.0; 1.0 1.0]),\n    b = [4.0, 2.0],\n    l = [0.0, 0.0],\n    u = [Inf, Inf],\n    vars = [\"x1\", \"x2\"],\n    constraint_types = ['L', 'L']\n)\n\nsolution, optimal_value = revised_simplex(lp)\nprintln(\"Optimal solution: \", solution)\nprintln(\"Optimal value: \", optimal_value)","category":"page"},{"location":"lp_revised_simplex/#Notes","page":"lp_revised_simplex","title":"Notes","text":"","category":"section"},{"location":"lp_revised_simplex/","page":"lp_revised_simplex","title":"lp_revised_simplex","text":"This function prints detailed iteration logs, including the current basis, reduced costs, dual variables, and any entering or leaving variables.\nThe function assumes that the LP problem is bounded and feasible. If the problem is unbounded or a maximum number of iterations is reached (set at 10 for demonstration purposes), the function will terminate with an error.","category":"page"},{"location":"lp_revised_simplex/#Examples","page":"lp_revised_simplex","title":"Examples","text":"","category":"section"},{"location":"lp_revised_simplex/#Solving-a-Linear-Programming-Problem","page":"lp_revised_simplex","title":"Solving a Linear Programming Problem","text":"","category":"section"},{"location":"lp_revised_simplex/","page":"lp_revised_simplex","title":"lp_revised_simplex","text":"lp = LPProblem(\n    is_minimize = true,\n    c = [-3.0, -2.0],\n    A = sparse([1.0 2.0; 1.0 1.0]),\n    b = [4.0, 2.0],\n    l = [0.0, 0.0],\n    u = [Inf, Inf],\n    vars = [\"x1\", \"x2\"],\n    constraint_types = ['L', 'L']\n)\n\nsolution, optimal_value = revised_simplex(lp)\nprintln(\"Optimal solution: \", solution)\nprintln(\"Optimal value: \", optimal_value)","category":"page"},{"location":"lp_revised_simplex/","page":"lp_revised_simplex","title":"lp_revised_simplex","text":"In this example, the revised simplex method is used to solve a simple linear programming problem with two decision variables, x1 and x2. The function finds the optimal values of the decision variables and calculates the optimal objective value.","category":"page"},{"location":"lp_problem/#lp_problem-Module","page":"lp_problem","title":"lp_problem Module","text":"","category":"section"},{"location":"lp_problem/","page":"lp_problem","title":"lp_problem","text":"The lp_problem module defines data structures that represent linear programming (LP) and mixed integer programming (MIP) problems. It also provides a structure for handling preprocessed LP problems.","category":"page"},{"location":"lp_problem/#Structs","page":"lp_problem","title":"Structs","text":"","category":"section"},{"location":"lp_problem/#LPProblem","page":"lp_problem","title":"LPProblem","text":"","category":"section"},{"location":"lp_problem/","page":"lp_problem","title":"lp_problem","text":"lp_problem.LPProblem","category":"page"},{"location":"lp_problem/#Main.lp_problem.LPProblem","page":"lp_problem","title":"Main.lp_problem.LPProblem","text":"struct LPProblem\n\nRepresents a standard Linear Programming (LP) problem.\n\nFields:\n\nis_minimize::Bool: true if the objective is to minimize, false if it is to maximize.\nc::Vector{Float64}: The objective function coefficients.\nA::SparseMatrixCSC{Float64, Int64}: The sparse constraint matrix.\nb::Vector{Float64}: The right-hand side values of the constraints.\nl::Vector{Float64}: The lower bounds for the decision variables.\nu::Vector{Float64}: The upper bounds for the decision variables.\nvars::Vector{String}: The names of the decision variables.\nconstraint_types::Vector{Char}: The types of constraints (e.g., <=, >=, =).\n\n\n\n\n\n","category":"type"},{"location":"lp_problem/","page":"lp_problem","title":"lp_problem","text":"The LPProblem struct is used to represent a linear programming problem. It contains the following fields:","category":"page"},{"location":"lp_problem/","page":"lp_problem","title":"lp_problem","text":"is_minimize::Bool: Whether the problem is a minimization problem (true) or maximization (false).\nc::Vector{Float64}: The coefficients of the objective function.\nA::SparseMatrixCSC{Float64, Int64}: The sparse matrix of constraints.\nb::Vector{Float64}: The right-hand side values of the constraints.\nl::Vector{Float64}: The lower bounds for the decision variables.\nu::Vector{Float64}: The upper bounds for the decision variables.\nvars::Vector{String}: The names of the decision variables.\nconstraint_types::Vector{Char}: The types of constraints (e.g., <=, >=, =).","category":"page"},{"location":"lp_problem/#MIPProblem","page":"lp_problem","title":"MIPProblem","text":"","category":"section"},{"location":"lp_problem/","page":"lp_problem","title":"lp_problem","text":"lp_problem.MIPProblem","category":"page"},{"location":"lp_problem/#Main.lp_problem.MIPProblem","page":"lp_problem","title":"Main.lp_problem.MIPProblem","text":"struct MIPProblem\n\nRepresents a Mixed Integer Programming (MIP) problem. Extends the LPProblem struct to include variable types.\n\nFields:\n\nis_minimize::Bool: true if the objective is to minimize, false if it is to maximize.\nc::Vector{Float64}: The objective function coefficients.\nA::SparseMatrixCSC{Float64, Int64}: The sparse constraint matrix.\nb::Vector{Float64}: The right-hand side values of the constraints.\nl::Vector{Float64}: The lower bounds for the decision variables.\nu::Vector{Float64}: The upper bounds for the decision variables.\nvars::Vector{String}: The names of the decision variables.\nvariable_types::Vector{Symbol}: The types of variables (e.g., :Binary, :Integer, :Continuous).\nconstraint_types::Vector{Char}: The types of constraints (e.g., <=, >=, =).\n\n\n\n\n\n","category":"type"},{"location":"lp_problem/","page":"lp_problem","title":"lp_problem","text":"The MIPProblem struct extends LPProblem to include information about the variable types, making it suitable for mixed integer programming problems. It contains the following additional field:","category":"page"},{"location":"lp_problem/","page":"lp_problem","title":"lp_problem","text":"variable_types::Vector{Symbol}: The types of the variables, which can be :Binary, :Integer, or :Continuous.","category":"page"},{"location":"lp_problem/#PreprocessedLPProblem","page":"lp_problem","title":"PreprocessedLPProblem","text":"","category":"section"},{"location":"lp_problem/","page":"lp_problem","title":"lp_problem","text":"lp_problem.PreprocessedLPProblem","category":"page"},{"location":"lp_problem/#Main.lp_problem.PreprocessedLPProblem","page":"lp_problem","title":"Main.lp_problem.PreprocessedLPProblem","text":"struct PreprocessedLPProblem\n\nStores the original and reduced versions of an LP problem during preprocessing, as well as information about removed rows and columns.\n\nFields:\n\noriginal_problem::LPProblem: The original LP problem before preprocessing.\nreduced_problem::LPProblem: The reduced LP problem after preprocessing.\nremoved_rows::Vector{Int}: Indices of rows removed during preprocessing.\nremoved_cols::Vector{Int}: Indices of columns removed during preprocessing.\nrow_ratios::Dict{Int, Tuple{Int, Float64}}: Maps removed rows to their corresponding row and the ratio between them.\n\n\n\n\n\n","category":"type"},{"location":"lp_problem/","page":"lp_problem","title":"lp_problem","text":"The PreprocessedLPProblem struct is used to store both the original and preprocessed versions of a linear programming problem during preprocessing. It also keeps track of rows and columns that have been removed.","category":"page"},{"location":"lp_problem/","page":"lp_problem","title":"lp_problem","text":"original_problem::LPProblem: The original LP problem.\nreduced_problem::LPProblem: The reduced LP problem after preprocessing.\nremoved_rows::Vector{Int}: The indices of rows removed during preprocessing.\nremoved_cols::Vector{Int}: The indices of columns removed during preprocessing.\nrow_ratios::Dict{Int, Tuple{Int, Float64}}: Maps removed rows to their corresponding row and ratio.","category":"page"},{"location":"lp_problem/#Examples","page":"lp_problem","title":"Examples","text":"","category":"section"},{"location":"lp_problem/#Creating-an-LP-Problem","page":"lp_problem","title":"Creating an LP Problem","text":"","category":"section"},{"location":"lp_problem/","page":"lp_problem","title":"lp_problem","text":"To create a linear programming problem using the LPProblem struct:","category":"page"},{"location":"lp_problem/","page":"lp_problem","title":"lp_problem","text":"using lp_problem\n\nc = [1.0, 2.0, 3.0]\nA = sparse([1.0, 0.0, 0.0, 1.0, 1.0, 1.0], 2, 3)\nb = [4.0, 6.0]\nl = [0.0, 0.0, 0.0]\nu = [10.0, 10.0, 10.0]\nvars = [\"x1\", \"x2\", \"x3\"]\nconstraint_types = ['L', 'L']\n\nlp = LPProblem(true, c, A, b, l, u, vars, constraint_types)","category":"page"},{"location":"lp_standard_form_converter/#lp_standard_form_converter-Module","page":"lp_standard_form_converter","title":"lp_standard_form_converter Module","text":"","category":"section"},{"location":"lp_standard_form_converter/","page":"lp_standard_form_converter","title":"lp_standard_form_converter","text":"The lp_standard_form_converter module provides functions for converting linear programming (LP) and mixed integer programming (MIP) problems into their standard form. The standard form is necessary for the simplex method, it involved adding slack varibles to convert inequalities to equalities.","category":"page"},{"location":"lp_standard_form_converter/#Functions","page":"lp_standard_form_converter","title":"Functions","text":"","category":"section"},{"location":"lp_standard_form_converter/#convert_to_standard_form","page":"lp_standard_form_converter","title":"convert_to_standard_form","text":"","category":"section"},{"location":"lp_standard_form_converter/","page":"lp_standard_form_converter","title":"lp_standard_form_converter","text":"lp_standard_form_converter.convert_to_standard_form","category":"page"},{"location":"lp_standard_form_converter/#Main.lp_standard_form_converter.convert_to_standard_form","page":"lp_standard_form_converter","title":"Main.lp_standard_form_converter.convert_to_standard_form","text":"convert_to_standard_form(lp::LPProblem) -> (new_A::SparseMatrixCSC, new_b::Vector{Float64}, new_c::Vector{Float64})\n\nConverts a given LPProblem to its standard form, transforming the constraints and objective function to fit the requirements of the standard linear programming form.\n\nArguments\n\nlp::LPProblem: A struct representing the Linear Programming problem, containing the objective function, constraints, and bounds.\n\nReturns\n\nnew_A::SparseMatrixCSC: The transformed constraint matrix in standard form.\nnew_b::Vector{Float64}: The transformed right-hand side of the constraints.\nnew_c::Vector{Float64}: The transformed objective function coefficients.\n\nMethod Details\n\nHandles lower and upper bounds for variables by adding additional constraints if necessary.\nTransforms the problem to ensure all constraints are in the form of inequalities.\nAdjusts the objective function if the problem is a maximization (standard form assumes minimization).\n\n\n\n\n\n","category":"function"},{"location":"lp_standard_form_converter/","page":"lp_standard_form_converter","title":"lp_standard_form_converter","text":"This function transforms a given LPProblem into its standard form, which includes converting the objective function to a minimization problem, ensuring all constraints are inequalities, and handling variable bounds through additional constraints.","category":"page"},{"location":"lp_standard_form_converter/#Arguments","page":"lp_standard_form_converter","title":"Arguments","text":"","category":"section"},{"location":"lp_standard_form_converter/","page":"lp_standard_form_converter","title":"lp_standard_form_converter","text":"lp::LPProblem: A struct representing the Linear Programming problem, containing the objective function, constraints, and bounds.","category":"page"},{"location":"lp_standard_form_converter/#Returns","page":"lp_standard_form_converter","title":"Returns","text":"","category":"section"},{"location":"lp_standard_form_converter/","page":"lp_standard_form_converter","title":"lp_standard_form_converter","text":"new_A::SparseMatrixCSC: The transformed constraint matrix in standard form.\nnew_b::Vector{Float64}: The transformed right-hand side of the constraints.\nnew_c::Vector{Float64}: The transformed objective function coefficients.","category":"page"},{"location":"lp_standard_form_converter/#Method-Details","page":"lp_standard_form_converter","title":"Method Details","text":"","category":"section"},{"location":"lp_standard_form_converter/","page":"lp_standard_form_converter","title":"lp_standard_form_converter","text":"Handles lower and upper bounds for variables by adding additional constraints if necessary.\nEnsures all constraints are in the form of inequalities (either <= or >=).\nAdjusts the objective function to fit the standard form, which assumes a minimization problem.","category":"page"},{"location":"lp_standard_form_converter/#Usage-Example","page":"lp_standard_form_converter","title":"Usage Example","text":"","category":"section"},{"location":"lp_standard_form_converter/","page":"lp_standard_form_converter","title":"lp_standard_form_converter","text":"using lp_standard_form_converter\n\nlp = LPProblem(\n    is_minimize = false,  # Maximization problem\n    c = [2.0, 3.0],\n    A = sparse([1.0 1.0; 2.0 1.0]),\n    b = [5.0, 8.0],\n    l = [0.0, 0.0],\n    u = [Inf, Inf],\n    vars = [\"x1\", \"x2\"],\n    constraint_types = ['L', 'L']\n)\n\nnew_A, new_b, new_c = convert_to_standard_form(lp)\nprintln(\"New A: \", new_A)\nprintln(\"New b: \", new_b)\nprintln(\"New c: \", new_c)","category":"page"},{"location":"lp_standard_form_converter/","page":"lp_standard_form_converter","title":"lp_standard_form_converter","text":"","category":"page"},{"location":"lp_standard_form_converter/#convert_to_standard_form_mip","page":"lp_standard_form_converter","title":"convert_to_standard_form_mip","text":"","category":"section"},{"location":"lp_standard_form_converter/","page":"lp_standard_form_converter","title":"lp_standard_form_converter","text":"lp_standard_form_converter.convert_to_standard_form_mip","category":"page"},{"location":"lp_standard_form_converter/#Main.lp_standard_form_converter.convert_to_standard_form_mip","page":"lp_standard_form_converter","title":"Main.lp_standard_form_converter.convert_to_standard_form_mip","text":"convert_to_standard_form_mip(mip::MIPProblem) -> (new_A::SparseMatrixCSC, new_b::Vector{Float64}, new_c::Vector{Float64}, new_variable_types::Vector{Symbol})\n\nConverts a given MIPProblem to its standard form, transforming the constraints and objective function to fit the requirements of the standard mixed integer programming form.\n\nArguments\n\nmip::MIPProblem: A struct representing the Mixed Integer Programming problem, containing the objective function, constraints, bounds, and variable types.\n\nReturns\n\nnew_A::SparseMatrixCSC: The transformed constraint matrix in standard form.\nnew_b::Vector{Float64}: The transformed right-hand side of the constraints.\nnew_c::Vector{Float64}: The transformed objective function coefficients.\nnew_variable_types::Vector{Symbol}: The updated variable types, including new slack variables added during the transformation.\n\nMethod Details\n\nAdds constraints to handle lower and upper bounds by introducing slack variables.\nEnsures all constraints are in standard form (inequalities) and adjusts the right-hand side appropriately.\nAdjusts the objective function if the problem is a maximization (standard form assumes minimization).\n\n\n\n\n\n","category":"function"},{"location":"lp_standard_form_converter/","page":"lp_standard_form_converter","title":"lp_standard_form_converter","text":"This function transforms a given MIPProblem into its standard form, which includes converting the objective function to a minimization problem, ensuring all constraints are inequalities, and handling variable bounds and types through additional constraints and slack variables.","category":"page"},{"location":"lp_standard_form_converter/#Arguments-2","page":"lp_standard_form_converter","title":"Arguments","text":"","category":"section"},{"location":"lp_standard_form_converter/","page":"lp_standard_form_converter","title":"lp_standard_form_converter","text":"mip::MIPProblem: A struct representing the Mixed Integer Programming problem, containing the objective function, constraints, bounds, and variable types.","category":"page"},{"location":"lp_standard_form_converter/#Returns-2","page":"lp_standard_form_converter","title":"Returns","text":"","category":"section"},{"location":"lp_standard_form_converter/","page":"lp_standard_form_converter","title":"lp_standard_form_converter","text":"new_A::SparseMatrixCSC: The transformed constraint matrix in standard form.\nnew_b::Vector{Float64}: The transformed right-hand side of the constraints.\nnew_c::Vector{Float64}: The transformed objective function coefficients.\nnew_variable_types::Vector{Symbol}: The updated variable types, including any slack variables added during the transformation.","category":"page"},{"location":"lp_standard_form_converter/#Method-Details-2","page":"lp_standard_form_converter","title":"Method Details","text":"","category":"section"},{"location":"lp_standard_form_converter/","page":"lp_standard_form_converter","title":"lp_standard_form_converter","text":"Adds constraints to handle lower and upper bounds by introducing slack variables.\nEnsures all constraints are in standard form (inequalities) and adjusts the right-hand side accordingly.\nAdjusts the objective function if the problem is a maximization (standard form assumes minimization).","category":"page"},{"location":"lp_standard_form_converter/#Usage-Example-2","page":"lp_standard_form_converter","title":"Usage Example","text":"","category":"section"},{"location":"lp_standard_form_converter/","page":"lp_standard_form_converter","title":"lp_standard_form_converter","text":"using lp_standard_form_converter\n\nmip = MIPProblem(\n    is_minimize = false,  # Maximization problem\n    c = [4.0, 5.0],\n    A = sparse([3.0 2.0; 4.0 1.0]),\n    b = [6.0, 5.0],\n    l = [0.0, 0.0],\n    u = [Inf, Inf],\n    vars = [\"x1\", \"x2\"],\n    variable_types = [:Binary, :Integer],\n    constraint_types = ['L', 'L']\n)\n\nnew_A, new_b, new_c, new_variable_types = convert_to_standard_form_mip(mip)\nprintln(\"New A: \", new_A)\nprintln(\"New b: \", new_b)\nprintln(\"New c: \", new_c)\nprintln(\"New variable types: \", new_variable_types)","category":"page"},{"location":"lp_standard_form_converter/#Additional-Information","page":"lp_standard_form_converter","title":"Additional Information","text":"","category":"section"},{"location":"lp_standard_form_converter/","page":"lp_standard_form_converter","title":"lp_standard_form_converter","text":"Converting LP and MIP problems to standard form is essential for many solvers, as it ensures that the problem is in a form that the solver can handle efficiently.","category":"page"},{"location":"lp_standard_form_converter/","page":"lp_standard_form_converter","title":"lp_standard_form_converter","text":"","category":"page"},{"location":"lp_standard_form_converter/","page":"lp_standard_form_converter","title":"lp_standard_form_converter","text":"For any questions or contributions, please refer to the project's GitHub repository.","category":"page"},{"location":"lp_presolve/#lp_presolve-Module","page":"lp_presolve","title":"lp_presolve Module","text":"","category":"section"},{"location":"lp_presolve/","page":"lp_presolve","title":"lp_presolve","text":"The lp_presolve module provides several utility functions for preprocessing linear programming problems by removing redundant rows, columns, and detecting linearly dependent constraints.","category":"page"},{"location":"lp_presolve/#Functions","page":"lp_presolve","title":"Functions","text":"","category":"section"},{"location":"lp_presolve/#lp_remove_zero_rows","page":"lp_presolve","title":"lp_remove_zero_rows","text":"","category":"section"},{"location":"lp_presolve/","page":"lp_presolve","title":"lp_presolve","text":"lp_presolve.lp_remove_zero_rows","category":"page"},{"location":"lp_presolve/#Main.lp_presolve.lp_remove_zero_rows","page":"lp_presolve","title":"Main.lp_presolve.lp_remove_zero_rows","text":"lp_remove_zero_rows(preprocessed_problem::PreprocessedLPProblem; ε::Float64=1e-8, debug::Bool=false)\n\nRemoves rows from the constraint matrix A of the PreprocessedLPProblem that consist only of zeros. \n\nArguments:\n\npreprocessed_problem: The PreprocessedLPProblem struct that contains the original and reduced problem.\nε: Threshold below which values are considered zero. Defaults to 1e-8.\ndebug: If true, prints debugging information. Defaults to false.\n\nReturns:\n\nA new PreprocessedLPProblem with rows removed from the reduced problem.\n\n\n\n\n\n","category":"function"},{"location":"lp_presolve/#lp_remove_row_singletons","page":"lp_presolve","title":"lp_remove_row_singletons","text":"","category":"section"},{"location":"lp_presolve/","page":"lp_presolve","title":"lp_presolve","text":"lp_presolve.lp_remove_row_singletons","category":"page"},{"location":"lp_presolve/#Main.lp_presolve.lp_remove_row_singletons","page":"lp_presolve","title":"Main.lp_presolve.lp_remove_row_singletons","text":"lp_remove_zero_columns(preprocessed_lp::PreprocessedLPProblem; ε::Float64=1e-8, debug::Bool=false)\n\nRemoves columns from the constraint matrix A of the PreprocessedLPProblem that consist only of zeros.\n\nArguments:\n\npreprocessed_lp: The PreprocessedLPProblem struct containing the original and reduced problem.\nε: Threshold below which values are considered zero. Defaults to 1e-8.\ndebug: If true, prints debugging information. Defaults to false.\n\nReturns:\n\nA new PreprocessedLPProblem with columns removed from the reduced problem.\n\n\n\n\n\n","category":"function"},{"location":"lp_presolve/#lp_remove_zero_columns","page":"lp_presolve","title":"lp_remove_zero_columns","text":"","category":"section"},{"location":"lp_presolve/","page":"lp_presolve","title":"lp_presolve","text":"lp_presolve.lp_remove_zero_columns","category":"page"},{"location":"lp_presolve/#Main.lp_presolve.lp_remove_zero_columns","page":"lp_presolve","title":"Main.lp_presolve.lp_remove_zero_columns","text":"lp_remove_linearly_dependent_rows(preprocessed_lp::PreprocessedLPProblem; ε::Float64=1e-8, debug::Bool=false)\n\nRemoves linearly dependent rows from the constraint matrix A of the PreprocessedLPProblem. Detects and eliminates rows that are linear combinations of other rows.\n\nArguments:\n\npreprocessed_lp: The PreprocessedLPProblem struct containing the original and reduced problem.\nε: Threshold below which values are considered zero. Defaults to 1e-8.\ndebug: If true, prints debugging information. Defaults to false.\n\nReturns:\n\nA new PreprocessedLPProblem with linearly dependent rows removed.\n\n\n\n\n\n","category":"function"},{"location":"lp_presolve/#lp_remove_linearly_dependent_rows","page":"lp_presolve","title":"lp_remove_linearly_dependent_rows","text":"","category":"section"},{"location":"lp_presolve/","page":"lp_presolve","title":"lp_presolve","text":"lp_presolve.lp_remove_linearly_dependent_rows","category":"page"},{"location":"lp_presolve/#Main.lp_presolve.lp_remove_linearly_dependent_rows","page":"lp_presolve","title":"Main.lp_presolve.lp_remove_linearly_dependent_rows","text":"lp_remove_linearly_dependent_rows(preprocessed_lp::PreprocessedLPProblem; ε::Float64=1e-8, debug::Bool=false)\n\nRemoves linearly dependent rows from the constraint matrix A of the PreprocessedLPProblem. Detects and eliminates rows that are linear combinations of other rows.\n\nArguments:\n\npreprocessed_lp: The PreprocessedLPProblem struct containing the original and reduced problem.\nε: Threshold below which values are considered zero. Defaults to 1e-8.\ndebug: If true, prints debugging information. Defaults to false.\n\nReturns:\n\nA new PreprocessedLPProblem with linearly dependent rows removed.\n\n\n\n\n\n","category":"function"},{"location":"lp_presolve/#presolve_lp","page":"lp_presolve","title":"presolve_lp","text":"","category":"section"},{"location":"lp_presolve/","page":"lp_presolve","title":"lp_presolve","text":"lp_presolve.presolve_lp","category":"page"},{"location":"lp_presolve/#Main.lp_presolve.presolve_lp","page":"lp_presolve","title":"Main.lp_presolve.presolve_lp","text":"presolve_lp(lp_problem::LPProblem; debug::Bool=false)\n\nApplies presolve routines to the given LPProblem to reduce the problem size by removing redundant rows and columns.\n\nArguments:\n\nlp_problem: The LPProblem to be presolved.\ndebug: If true, prints debugging information for each presolve step. Defaults to false.\n\nReturns:\n\nA PreprocessedLPProblem with a reduced problem that excludes zero rows, zero columns, singleton rows, and linearly dependent rows.\n\n\n\n\n\n","category":"function"},{"location":"lp_presolve/#Examples","page":"lp_presolve","title":"Examples","text":"","category":"section"},{"location":"lp_presolve/","page":"lp_presolve","title":"lp_presolve","text":"Here’s an example of how to use the lp_presolve module:","category":"page"},{"location":"lp_presolve/","page":"lp_presolve","title":"lp_presolve","text":"using lp_presolve\n\n# Create an LP problem (lp_problem)\npreprocessed_lp = presolve_lp(lp_problem, debug=true)\n\n# Check the results after presolve\nprintln(\"Preprocessed Problem: \", preprocessed_lp)","category":"page"},{"location":"lp_read_mps/#lp_read_mps-Module","page":"lp_read_mps","title":"lp_read_mps Module","text":"","category":"section"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"The lp_read_mps module provides functions for reading linear programming problems from MPS (Mathematical Programming System) files. These functions support both standard LP problems and Mixed Integer Programming (MIP) problems.","category":"page"},{"location":"lp_read_mps/#Functions","page":"lp_read_mps","title":"Functions","text":"","category":"section"},{"location":"lp_read_mps/#read_mps_from_string","page":"lp_read_mps","title":"read_mps_from_string","text":"","category":"section"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"lp_read_mps.read_mps_from_string","category":"page"},{"location":"lp_read_mps/#Main.lp_read_mps.read_mps_from_string","page":"lp_read_mps","title":"Main.lp_read_mps.read_mps_from_string","text":"read_mps_from_string(mps_string::String) -> LPProblem\n\nThis function parses a given MPS (Mathematical Programming System) formatted string and converts it into an LPProblem struct, representing a Linear Programming (LP) problem in Julia.\n\nArguments:\n\nmps_string::String: A string representing the content of an MPS file.\n\nReturns:\n\nLPProblem: A struct containing the LP problem data.\n\n\n\n\n\n","category":"function"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"Reads an MPS problem from a string input and converts it into an LPProblem struct.","category":"page"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"Usage Example:","category":"page"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"mps_string = \"\"\"\nNAME          TESTPROB\nROWS\n N  OBJ\n L  CON1\n G  CON2\n...\nENDATA\n\"\"\"\nlp_problem = read_mps_from_string(mps_string)","category":"page"},{"location":"lp_read_mps/#read_mps_from_file","page":"lp_read_mps","title":"read_mps_from_file","text":"","category":"section"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"lp_read_mps.read_mps_from_file","category":"page"},{"location":"lp_read_mps/#Main.lp_read_mps.read_mps_from_file","page":"lp_read_mps","title":"Main.lp_read_mps.read_mps_from_file","text":"read_mps_from_file(file_path::String) -> LPProblem\n\nReads an MPS file and converts it into an LPProblem struct.\n\nArguments\n\nfile_path::String: The path to the MPS file.\n\nReturns\n\nLPProblem: A struct containing the LP problem data.\n\n\n\n\n\n","category":"function"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"Reads an MPS problem from a file and converts it into an LPProblem struct.","category":"page"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"Usage Example:","category":"page"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"julia\nlp_problem = read_mps_from_file(\"path/to/file.mps\")","category":"page"},{"location":"lp_read_mps/#read_mps_from_string_mip","page":"lp_read_mps","title":"read_mps_from_string_mip","text":"","category":"section"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"lp_read_mps.read_mps_from_string_mip","category":"page"},{"location":"lp_read_mps/#Main.lp_read_mps.read_mps_from_string_mip","page":"lp_read_mps","title":"Main.lp_read_mps.read_mps_from_string_mip","text":"read_mps_from_string_mip(mps_string::String) -> MIPProblem\n\nParses a given MPS formatted string and converts it into a MIPProblem struct.\n\nArguments\n\nmps_string::String: A string representing the content of an MPS file.\n\nReturns\n\nMIPProblem: A struct containing the MIP problem data.\n\n\n\n\n\n","category":"function"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"Reads a Mixed Integer Programming (MIP) problem from a string input and converts it into a MIPProblem struct.","category":"page"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"Usage Example:","category":"page"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"mps_string_mip = \"\"\"\nNAME          TESTMIP\nROWS\n N  OBJ\n L  CON1\n G  CON2\n...\nENDATA\n\"\"\"\nmip_problem = read_mps_from_string_mip(mps_string_mip)","category":"page"},{"location":"lp_read_mps/#read_mps_from_file_mip","page":"lp_read_mps","title":"read_mps_from_file_mip","text":"","category":"section"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"lp_read_mps.read_mps_from_file_mip","category":"page"},{"location":"lp_read_mps/#Main.lp_read_mps.read_mps_from_file_mip","page":"lp_read_mps","title":"Main.lp_read_mps.read_mps_from_file_mip","text":"read_mps_from_file_mip(file_path::String) -> MIPProblem\n\nReads an MPS file and converts it into a MIPProblem struct.\n\nArguments\n\nfile_path::String: The path to the MPS file.\n\nReturns\n\nMIPProblem: A struct containing the MIP problem data.\n\n\n\n\n\n","category":"function"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"Reads a Mixed Integer Programming (MIP) problem from a file and converts it into a MIPProblem struct.","category":"page"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"Usage Example:","category":"page"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"mip_problem = read_mps_from_file_mip(\"path/to/file.mps\")","category":"page"},{"location":"lp_read_mps/#read_file_to_string","page":"lp_read_mps","title":"read_file_to_string","text":"","category":"section"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"lp_read_mps.read_file_to_string","category":"page"},{"location":"lp_read_mps/#Main.lp_read_mps.read_file_to_string","page":"lp_read_mps","title":"Main.lp_read_mps.read_file_to_string","text":"read_file_to_string(file_path::String) -> String\n\nReads the contents of a file and returns it as a string.\n\nArguments\n\nfile_path::String: The path to the file.\n\nReturns\n\nString: The contents of the file as a string.\n\n\n\n\n\n","category":"function"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"Reads the contents of a file and returns it as a string. This is often used to read MPS files into a string format before parsing them into a problem structure.","category":"page"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"Usage Example:","category":"page"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"mps_string = read_file_to_string(\"path/to/file.mps\")","category":"page"},{"location":"lp_read_mps/#get_variable_type","page":"lp_read_mps","title":"get_variable_type","text":"","category":"section"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"lp_read_mps.get_variable_type","category":"page"},{"location":"lp_read_mps/#Main.lp_read_mps.get_variable_type","page":"lp_read_mps","title":"Main.lp_read_mps.get_variable_type","text":"get_variable_type(var) -> String\n\nDetermines the type of a variable in a mathematical optimization model.\n\nArguments\n\nvar: The variable whose type is to be determined. This is typically a variable from a mathematical optimization model, such as a JuMP variable.\n\nReturns\n\nString: The type of the variable as a string. Possible values are:\n\"Binary\": If the variable is binary (i.e., it can take values 0 or 1).\n\"Integer\": If the variable is an integer (i.e., it can take integer values).\n\"Continuous\": If the variable is continuous (i.e., it can take any real value).\n\nExample\n\nvar = @variable(model, Bin)\nprintln(get_variable_type(var))  # Outputs \"Binary\"\n\nThis function uses is_binary and is_integer to determine whether a variable is binary, integer, or continuous. \n\n\n\n\n\n","category":"function"},{"location":"lp_read_mps/#read_mps_with_JuMP_MIP","page":"lp_read_mps","title":"read_mps_with_JuMP_MIP","text":"","category":"section"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"lp_read_mps.read_mps_with_JuMP_MIP","category":"page"},{"location":"lp_read_mps/#Main.lp_read_mps.read_mps_with_JuMP_MIP","page":"lp_read_mps","title":"Main.lp_read_mps.read_mps_with_JuMP_MIP","text":"read_mps_with_JuMP_MIP(file_path::String) -> MIPProblem\n\nReads an MPS file using JuMP and converts it into a MIPProblem struct.\n\nArguments\n\nfile_path::String: The path to the MPS file.\n\nReturns\n\nMIPProblem: A struct containing the MIP problem data.\n\n\n\n\n\n","category":"function"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"Reads a Mixed Integer Programming (MIP) problem from an MPS file using JuMP and converts it into a MIPProblem struct. This function relies on the JuMP and MathOptInterface packages for parsing and handling MIP problems.","category":"page"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"Usage Example:","category":"page"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"mip_problem = read_mps_with_JuMP_MIP(\"path/to/file.mps\")","category":"page"},{"location":"lp_read_mps/#Examples","page":"lp_read_mps","title":"Examples","text":"","category":"section"},{"location":"lp_read_mps/#Reading-an-LP-Problem-from-an-MPS-File","page":"lp_read_mps","title":"Reading an LP Problem from an MPS File","text":"","category":"section"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"lp_problem = read_mps_from_file(\"examples/test.mps\")\nprintln(lp_problem)","category":"page"},{"location":"lp_read_mps/#Reading-a-MIP-Problem-from-a-String","page":"lp_read_mps","title":"Reading a MIP Problem from a String","text":"","category":"section"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"mps_string = \"\"\"\nNAME          BLEND\nROWS\n N  PROFIT\n L  LIMIT1\n G  LIMIT2\n...\nENDATA\n\"\"\"\nmip_problem = read_mps_from_string_mip(mps_string)\nprintln(mip_problem)","category":"page"},{"location":"lp_read_mps/#Additional-Information","page":"lp_read_mps","title":"Additional Information","text":"","category":"section"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"The lp_read_mps module provides tools for handling MPS files, which are commonly used in optimization tasks. These files encode linear and mixed integer programming problems in a standard format that can be parsed and processed by solvers.","category":"page"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"For more detailed information on the MPS format, refer to MPS documentation.","category":"page"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"","category":"page"},{"location":"lp_read_mps/","page":"lp_read_mps","title":"lp_read_mps","text":"For any questions or contributions, please refer to the project's GitHub repository.","category":"page"},{"location":"#Project-Documentation","page":"Home","title":"Project Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for this project, which provides tools and utilities for solving linear programming (LP) and mixed integer programming (MIP) problems. The project is organized into different modules, each focusing on specific aspects of problem-solving, including preprocessing, problem formulation, and solution techniques.","category":"page"},{"location":"#Modules","page":"Home","title":"Modules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"lp_presolve: This module provides functions for preprocessing LP problems, such as removing zero rows, zero columns, and linearly dependent rows.\nlp_problem: This module defines the data structures for representing LP and MIP problems, including the LPProblem, MIPProblem, and PreprocessedLPProblem structs.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To begin using the tools in this project, follow these steps:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Install the required dependencies: You will need to install Julia and any required packages for this project (e.g., SparseArrays, Documenter).\nExplore the Modules: Visit the module pages linked above to learn more about the functions and data structures provided by each module.\nExamples: Each module page provides examples on how to create LP/MIP problems, preprocess them, and solve them.","category":"page"},{"location":"#About-the-Project","page":"Home","title":"About the Project","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project focuses on solving optimization problems using linear programming and mixed integer programming techniques. It includes modules that help preprocess problems, formulate them, and solve them using various methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more detailed information, explore the individual modules and example usage.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"For any questions or contributions, please refer to the project's GitHub repository.","category":"page"},{"location":"lp_solver/#lp_solver-Module","page":"lp_solver","title":"lp_solver Module","text":"","category":"section"},{"location":"lp_solver/","page":"lp_solver","title":"lp_solver","text":"The lp_solver module provides functionality to load, parse, and solve linear programming (LP) problems from MPS files. It supports different methods for solving LP problems, including the simplex method, and allows for command-line argument parsing to configure the solver.","category":"page"},{"location":"lp_solver/#Functions","page":"lp_solver","title":"Functions","text":"","category":"section"},{"location":"lp_solver/#parse_commandline","page":"lp_solver","title":"parse_commandline","text":"","category":"section"},{"location":"lp_solver/","page":"lp_solver","title":"lp_solver","text":"lp_solver.parse_commandline","category":"page"},{"location":"lp_solver/#Main.lp_solver.parse_commandline","page":"lp_solver","title":"Main.lp_solver.parse_commandline","text":"parse_commandline() -> Dict\n\nParses command-line arguments using the ArgParse package. It defines options such as the problem file path, method type (simplex or interior point), optimization type (minimization or maximization), and verbosity.\n\nReturns\n\nDict: A dictionary of parsed arguments.\n\nCommand-Line Arguments\n\n--filename, -f: Path to the problem file in MPS format (required).\n--interior, -i: Use the interior point method (LP only).\n--min: Minimize the objective function (default).\n--max: Maximize the objective function.\n--no_presolve: Skip the presolve step (default is false).\n--simplex, -s: Use the simplex method (default).\n--verbose, -v: Enable verbose output.\n\n\n\n\n\n","category":"function"},{"location":"lp_solver/","page":"lp_solver","title":"lp_solver","text":"Parses command-line arguments using the ArgParse package. The following options are supported:","category":"page"},{"location":"lp_solver/","page":"lp_solver","title":"lp_solver","text":"--filename, -f: Path to the problem file in MPS format (required).\n--interior, -i: Use the interior point method (LP only).\n--min: Minimize the objective function (default).\n--max: Maximize the objective function.\n--no_presolve: Skip the presolve step (default is false).\n--simplex, -s: Use the simplex method (default).\n--verbose, -v: Enable verbose output.","category":"page"},{"location":"lp_solver/#Example-Usage","page":"lp_solver","title":"Example Usage","text":"","category":"section"},{"location":"lp_solver/","page":"lp_solver","title":"lp_solver","text":"bash\njulia lp_solver.jl --filename problem.mps --simplex --min --verbose","category":"page"},{"location":"lp_solver/","page":"lp_solver","title":"lp_solver","text":"","category":"page"},{"location":"lp_solver/#load_lp_problem_from_mps","page":"lp_solver","title":"load_lp_problem_from_mps","text":"","category":"section"},{"location":"lp_solver/","page":"lp_solver","title":"lp_solver","text":"lp_solver.load_lp_problem_from_mps","category":"page"},{"location":"lp_solver/#Main.lp_solver.load_lp_problem_from_mps","page":"lp_solver","title":"Main.lp_solver.load_lp_problem_from_mps","text":"load_lp_problem_from_mps(filename::String) -> LPProblem\n\nLoads a linear programming (LP) problem from an MPS file. It uses the read_mps_from_file function to read and parse the problem into an LPProblem struct.\n\nArguments\n\nfilename::String: The path to the MPS file containing the LP problem.\n\nReturns\n\nLPProblem: The parsed LP problem struct.\n\nExample\n\nlp = load_lp_problem_from_mps(\"problem.mps\")\n\n\n\n\n\n","category":"function"},{"location":"lp_solver/","page":"lp_solver","title":"lp_solver","text":"Loads a linear programming problem from an MPS file and returns an LPProblem struct.","category":"page"},{"location":"lp_solver/#Example-Usage-2","page":"lp_solver","title":"Example Usage","text":"","category":"section"},{"location":"lp_solver/","page":"lp_solver","title":"lp_solver","text":"lp = load_lp_problem_from_mps(\"problem.mps\")\nprintln(lp)","category":"page"},{"location":"lp_solver/","page":"lp_solver","title":"lp_solver","text":"","category":"page"},{"location":"lp_solver/#handle_lp_operations","page":"lp_solver","title":"handle_lp_operations","text":"","category":"section"},{"location":"lp_solver/","page":"lp_solver","title":"lp_solver","text":"lp_solver.handle_lp_operations","category":"page"},{"location":"lp_solver/#Main.lp_solver.handle_lp_operations","page":"lp_solver","title":"Main.lp_solver.handle_lp_operations","text":"handle_lp_operations(parsed_args::Dict)\n\nHandles the operations required to solve the LP problem based on the parsed command-line arguments. It decides which method (simplex or interior point) to use, whether to presolve, and whether to minimize or maximize the objective function.\n\nArguments\n\nparsed_args::Dict: The parsed command-line arguments, including options such as the file path, optimization method, and presolve option.\n\nExample\n\nhandle_lp_operations(parsed_args)\n\n\n\n\n\n","category":"function"},{"location":"lp_solver/","page":"lp_solver","title":"lp_solver","text":"This function processes the LP problem based on the parsed command-line arguments and decides whether to run the simplex method, skip presolve, or use an interior point method (if implemented).","category":"page"},{"location":"lp_solver/#Example-Usage-3","page":"lp_solver","title":"Example Usage","text":"","category":"section"},{"location":"lp_solver/","page":"lp_solver","title":"lp_solver","text":"handle_lp_operations(parsed_args)","category":"page"},{"location":"lp_solver/#main","page":"lp_solver","title":"main","text":"","category":"section"},{"location":"lp_solver/","page":"lp_solver","title":"lp_solver","text":"lp_solver.main ","category":"page"},{"location":"lp_solver/#Main.lp_solver.main","page":"lp_solver","title":"Main.lp_solver.main","text":"main()\n\nThe main function that orchestrates the entire LP solving process. It parses command-line arguments, handles problem type (minimization or maximization), and calls the appropriate method (simplex or interior point) based on user input.\n\nExample\n\njulia we_need_a_name.jl --filename \"../check/problems/mps_files/ex_9-7.mps\" --min --simplex --no_presolve --verbose\n\n\n\n\n\n","category":"function"},{"location":"lp_solver/","page":"lp_solver","title":"lp_solver","text":"The main execution function for the lp_solver module. It parses command-line arguments, handles the problem type (minimization or maximization), and calls the appropriate solving method.","category":"page"},{"location":"lp_solver/","page":"lp_solver","title":"lp_solver","text":"Example Command Run the solver with the following command:","category":"page"},{"location":"lp_solver/","page":"lp_solver","title":"lp_solver","text":"julia we_need_a_name.jl --filename \"../check/problems/mps_files/ex_9-7.mps\" --min --simplex --no_presolve --verbose","category":"page"},{"location":"lp_solver/","page":"lp_solver","title":"lp_solver","text":"Additional Information","category":"page"},{"location":"lp_solver/","page":"lp_solver","title":"lp_solver","text":"The lp_solver module is designed to be used with command-line tools and can load and solve linear programming problems in MPS format. By using the various arguments, you can customize how the problem is solved and which method is used.","category":"page"}]
}
