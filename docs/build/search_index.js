var documenterSearchIndex = {"docs":
[{"location":"LpRevisedSimplex/#LpRevisedSimplex-Module","page":"LpRevisedSimplex","title":"LpRevisedSimplex Module","text":"","category":"section"},{"location":"LpRevisedSimplex/","page":"LpRevisedSimplex","title":"LpRevisedSimplex","text":"The LpRevisedSimplex module provides an implementation of the revised simplex method for solving linear programming (LP) problems.","category":"page"},{"location":"LpRevisedSimplex/#Functions","page":"LpRevisedSimplex","title":"Functions","text":"","category":"section"},{"location":"LpRevisedSimplex/#RevisedSimplex","page":"LpRevisedSimplex","title":"RevisedSimplex","text":"","category":"section"},{"location":"LpRevisedSimplex/","page":"LpRevisedSimplex","title":"LpRevisedSimplex","text":"LpRevisedSimplex.revised_simplex","category":"page"},{"location":"LpRevisedSimplex/#Main.LpRevisedSimplex.revised_simplex","page":"LpRevisedSimplex","title":"Main.LpRevisedSimplex.revised_simplex","text":"revised_simplex(pp::PreprocessedLPProblem; verbose::Bool=false) -> (solution::Dict{String, Float64}, optimal_value::Float64)\n\nSolves a linear programming (LP) problem using the revised simplex method. This method works with the reduced problem  from the PreprocessedLPProblem struct and updates the original solution based on the preprocessing steps.\n\nArguments\n\npp::PreprocessedLPProblem: A PreprocessedLPProblem struct that contains the reduced LP problem, along with information about removed rows and columns, any variable solutions from preprocessing, and flags for infeasibility.\nverbose::Bool=false: Optional flag to enable detailed output during each iteration of the simplex process. \nIf true, prints step-by-step details of each iteration, including:\nBasic solution at each iteration.\nDual variables and reduced costs.\nEntering and leaving variables for the basis.\nUpdates to the basis and non-basic variables.\nFinal optimal solution and objective value.\n\nReturns\n\nsolution::Dict{String, Float64}: The solution as a dictionary mapping variable names to their solution values.\noptimal_value::Float64: The optimal value of the objective function, adjusted based on whether the original problem  was a maximization or minimization.\n\nRaises\n\nThrows an error if pp.is_infeasible == true, indicating that the problem has been flagged as infeasible during preprocessing.\nThrows an error if the problem is unbounded or if no optimal solution is found within the maximum number of iterations.\n\nMethod Overview\n\nConvert to Standard Form: \nConverts the reduced LP problem to standard form, ensuring minimization and equality constraints.\nSlack and surplus variables are added as needed.\nInitialization: \nInitializes the basis with the slack variables and sets up the LU factorization for solving the system.\nIteration Process:\nComputes the basic solution by solving the system of equations.\nCalculates reduced costs and identifies the entering and leaving variables based on the direction of improvement.\nAdjusts the basis and continues iterating until an optimal solution is found, or the problem is determined to be unbounded.\nOptimal Solution and Mapping:\nOnce the optimal solution is found, the result is mapped back to the original variable names.\nIf any variables were pre-solved during preprocessing, their solutions are included.\nThe final objective value is adjusted based on whether the original problem was a maximization or minimization.\n\nVerbose Output:\n\nIf verbose=true, the function will print:\n\nIteration details (basic solution, reduced costs, dual variables).\nInformation about entering and leaving variables at each step.\nUpdates to the basis and non-basic variables after each iteration.\nThe final solution and the optimal objective value.\n\n\n\n\n\n","category":"function"},{"location":"LpRevisedSimplex/","page":"LpRevisedSimplex","title":"LpRevisedSimplex","text":"The RevisedSimplex function solves a linear programming problem using the revised simplex method. It takes an LPProblem struct as input, converts it to standard form, and iteratively finds the optimal solution using the simplex algorithm.","category":"page"},{"location":"LpRevisedSimplex/#Arguments","page":"LpRevisedSimplex","title":"Arguments","text":"","category":"section"},{"location":"LpRevisedSimplex/","page":"LpRevisedSimplex","title":"LpRevisedSimplex","text":"lp::LPProblem: An LPProblem struct representing the linear programming problem to be solved.","category":"page"},{"location":"LpRevisedSimplex/#Returns","page":"LpRevisedSimplex","title":"Returns","text":"","category":"section"},{"location":"LpRevisedSimplex/","page":"LpRevisedSimplex","title":"LpRevisedSimplex","text":"solution::Vector{Float64}: The optimal values for the decision variables in the LP problem.\noptimal_value::Float64: The optimal objective value, calculated from the solution.","category":"page"},{"location":"LpRevisedSimplex/#Method-Overview","page":"LpRevisedSimplex","title":"Method Overview","text":"","category":"section"},{"location":"LpRevisedSimplex/","page":"LpRevisedSimplex","title":"LpRevisedSimplex","text":"Converts the given LP problem to its standard form.\nInitializes the basis using slack variables.\nIteratively adjusts the basis, solving the LP problem.\nChecks for optimality by evaluating reduced costs.\nHandles unboundedness, if detected.\nReturns the optimal solution and objective value when found.","category":"page"},{"location":"LpRevisedSimplex/#Usage-Example","page":"LpRevisedSimplex","title":"Usage Example","text":"","category":"section"},{"location":"LpRevisedSimplex/","page":"LpRevisedSimplex","title":"LpRevisedSimplex","text":"lp = LPProblem(\n    is_minimize = true,\n    c = [-3.0, -2.0],\n    A = sparse([1.0 2.0; 1.0 1.0]),\n    b = [4.0, 2.0],\n    l = [0.0, 0.0],\n    u = [Inf, Inf],\n    vars = [\"x1\", \"x2\"],\n    constraint_types = ['L', 'L']\n)\n\nsolution, optimal_value = revised_simplex(lp)\nprintln(\"Optimal solution: \", solution)\nprintln(\"Optimal value: \", optimal_value)","category":"page"},{"location":"LpRevisedSimplex/#Notes","page":"LpRevisedSimplex","title":"Notes","text":"","category":"section"},{"location":"LpRevisedSimplex/","page":"LpRevisedSimplex","title":"LpRevisedSimplex","text":"This function prints detailed iteration logs, including the current basis, reduced costs, dual variables, and any entering or leaving variables.\nThe function assumes that the LP problem is bounded and feasible. If the problem is unbounded or a maximum number of iterations is reached (set at 10 for demonstration purposes), the function will terminate with an error.","category":"page"},{"location":"LpRevisedSimplex/#Examples","page":"LpRevisedSimplex","title":"Examples","text":"","category":"section"},{"location":"LpRevisedSimplex/#Solving-a-Linear-Programming-Problem","page":"LpRevisedSimplex","title":"Solving a Linear Programming Problem","text":"","category":"section"},{"location":"LpRevisedSimplex/","page":"LpRevisedSimplex","title":"LpRevisedSimplex","text":"lp = LPProblem(\n    is_minimize = true,\n    c = [-3.0, -2.0],\n    A = sparse([1.0 2.0; 1.0 1.0]),\n    b = [4.0, 2.0],\n    l = [0.0, 0.0],\n    u = [Inf, Inf],\n    vars = [\"x1\", \"x2\"],\n    constraint_types = ['L', 'L']\n)\n\nsolution, optimal_value = revised_simplex(lp)\nprintln(\"Optimal solution: \", solution)\nprintln(\"Optimal value: \", optimal_value)","category":"page"},{"location":"LpRevisedSimplex/","page":"LpRevisedSimplex","title":"LpRevisedSimplex","text":"In this example, the revised simplex method is used to solve a simple linear programming problem with two decision variables, x1 and x2. The function finds the optimal values of the decision variables and calculates the optimal objective value.","category":"page"},{"location":"juLinear/#juLinear-Module","page":"juLinear","title":"juLinear Module","text":"","category":"section"},{"location":"juLinear/","page":"juLinear","title":"juLinear","text":"The juLinear module provides functionality to load, parse, and solve linear programming (LP) problems from MPS files. It supports different methods for solving LP problems, including the simplex method, and allows for command-line argument parsing to configure the solver.","category":"page"},{"location":"juLinear/#Functions","page":"juLinear","title":"Functions","text":"","category":"section"},{"location":"juLinear/#parse_commandline","page":"juLinear","title":"parse_commandline","text":"","category":"section"},{"location":"juLinear/","page":"juLinear","title":"juLinear","text":"juLinear.parse_commandline","category":"page"},{"location":"juLinear/#Main.juLinear.parse_commandline","page":"juLinear","title":"Main.juLinear.parse_commandline","text":"parse_commandline() -> Dict\n\nParses command-line arguments using the ArgParse package. It defines options such as the problem file path, method type (simplex or interior point), and verbosity.\n\nReturns\n\nDict: A dictionary containing the parsed arguments.\n\nCommand-Line Arguments\n\n--filename, -f: Path to the problem file (LP or MPS format). If not provided, a default file path is used.\n--interior, -i: Use the interior point method (currently not implemented).\n--no_presolve: Skip the presolve step (default is false).\n--simplex, -s: Use the simplex method (default).\n--verbose, -v: Enable verbose output.\n\n\n\n\n\n","category":"function"},{"location":"juLinear/","page":"juLinear","title":"juLinear","text":"Parses command-line arguments using the ArgParse package. The following options are supported:","category":"page"},{"location":"juLinear/","page":"juLinear","title":"juLinear","text":"--filename, -f: Path to the problem file in MPS format (required).\n--interior, -i: Use the interior point method (LP only).\n--min: Minimize the objective function (default).\n--max: Maximize the objective function.\n--no_presolve: Skip the presolve step (default is false).\n--simplex, -s: Use the simplex method (default).\n--verbose, -v: Enable verbose output.","category":"page"},{"location":"juLinear/#Example-Usage","page":"juLinear","title":"Example Usage","text":"","category":"section"},{"location":"juLinear/","page":"juLinear","title":"juLinear","text":"bash\njulia juLinear.jl --filename problem.mps --simplex --min --verbose","category":"page"},{"location":"juLinear/","page":"juLinear","title":"juLinear","text":"","category":"page"},{"location":"juLinear/#load_lp_problem","page":"juLinear","title":"load_lp_problem","text":"","category":"section"},{"location":"juLinear/","page":"juLinear","title":"juLinear","text":"juLinear.load_lp_problem","category":"page"},{"location":"juLinear/#Main.juLinear.load_lp_problem","page":"juLinear","title":"Main.juLinear.load_lp_problem","text":"load_lp_problem(filename::String) -> LPProblem\n\nLoads a linear programming (LP) problem from an LP or MPS file.\n\nArguments\n\nfilename::String: The path to the LP/MPS file containing the problem.\n\nReturns\n\nLPProblem: The parsed LPProblem struct.\n\nExample\n\nlp = loadlpproblem(\"problem.lp\")\n\n\n\n\n\n","category":"function"},{"location":"juLinear/#Example-Usage-2","page":"juLinear","title":"Example Usage","text":"","category":"section"},{"location":"juLinear/","page":"juLinear","title":"juLinear","text":"lp = load_lp_problem(\"problem.mps\")\nprintln(lp)","category":"page"},{"location":"juLinear/","page":"juLinear","title":"juLinear","text":"","category":"page"},{"location":"juLinear/#handle_lp_operations","page":"juLinear","title":"handle_lp_operations","text":"","category":"section"},{"location":"juLinear/","page":"juLinear","title":"juLinear","text":"juLinear.handle_lp_operations","category":"page"},{"location":"juLinear/#Main.juLinear.handle_lp_operations","page":"juLinear","title":"Main.juLinear.handle_lp_operations","text":"handle_lp_operations(parsed_args::Dict)\n\nHandles the operations required to solve the LP problem based on the parsed command-line arguments. \n\nArguments\n\nparsed_args::Dict: The parsed command-line arguments, including options such as the file path, optimization method, and presolve option.\n\nExample\n\nhandlelpoperations(parsed_args)\n\n\n\n\n\n","category":"function"},{"location":"juLinear/","page":"juLinear","title":"juLinear","text":"This function processes the LP problem based on the parsed command-line arguments and decides whether to run the simplex method, skip presolve, or use an interior point method (if implemented).","category":"page"},{"location":"juLinear/#Example-Usage-3","page":"juLinear","title":"Example Usage","text":"","category":"section"},{"location":"juLinear/","page":"juLinear","title":"juLinear","text":"handle_lp_operations(parsed_args)","category":"page"},{"location":"juLinear/#main","page":"juLinear","title":"main","text":"","category":"section"},{"location":"juLinear/","page":"juLinear","title":"juLinear","text":"juLinear.main ","category":"page"},{"location":"juLinear/#Main.juLinear.main","page":"juLinear","title":"Main.juLinear.main","text":"main()\n\nThe main function that orchestrates the entire LP solving process. It parses command-line arguments and calls the appropriate method (simplex or interior point) based on user input.\n\nExample\n\njulia juLinear.jl --filename \"../check/problems/lp_files/ex_9-7.lp\" --simplex --no_presolve --verbose\n\n\n\n\n\n","category":"function"},{"location":"juLinear/","page":"juLinear","title":"juLinear","text":"The main execution function for the lp_solver module. It parses command-line arguments, handles the problem type (minimization or maximization), and calls the appropriate solving method.","category":"page"},{"location":"juLinear/","page":"juLinear","title":"juLinear","text":"Example Command Run the solver with the following command:","category":"page"},{"location":"juLinear/","page":"juLinear","title":"juLinear","text":"julia juLinear.jl --filename \"../check/problems/mps_files/ex_9-7.mps\" --min --simplex --no_presolve --verbose","category":"page"},{"location":"juLinear/","page":"juLinear","title":"juLinear","text":"Additional Information","category":"page"},{"location":"juLinear/","page":"juLinear","title":"juLinear","text":"The juLinear module is designed to be used with command-line tools and can load and solve linear programming problems in MPS format. By using the various arguments, you can customize how the problem is solved and which method is used.","category":"page"},{"location":"LpStandardFormConverter/#LpStandardFormConverter-Module","page":"LpStandardFormConverter","title":"LpStandardFormConverter Module","text":"","category":"section"},{"location":"LpStandardFormConverter/","page":"LpStandardFormConverter","title":"LpStandardFormConverter","text":"The LpStandardFormConverter module provides functions for converting linear programming (LP) problems into their standard form. The standard form involves adding slack varibles to convert inequalities to equalities and converting problem to a minimisation.","category":"page"},{"location":"LpStandardFormConverter/#Functions","page":"LpStandardFormConverter","title":"Functions","text":"","category":"section"},{"location":"LpStandardFormConverter/#convert_to_standard_form","page":"LpStandardFormConverter","title":"convert_to_standard_form","text":"","category":"section"},{"location":"LpStandardFormConverter/","page":"LpStandardFormConverter","title":"LpStandardFormConverter","text":"LpStandardFormConverter.convert_to_standard_form","category":"page"},{"location":"LpStandardFormConverter/#Main.LpStandardFormConverter.convert_to_standard_form","page":"LpStandardFormConverter","title":"Main.LpStandardFormConverter.convert_to_standard_form","text":"convert_to_standard_form(lp::LPProblem; verbose::Bool=false) -> LPProblem\n\nConvert a general linear programming (LP) problem into standard form.\n\nStandard Form:\n\nIn the standard form of an LP problem:\n\nThe objective function is always minimized.\nAll constraints are equalities (i.e., of the form Ax = b).\nAll variables are non-negative (i.e., x ≥ 0).\n\nArguments:\n\nlp::LPProblem: The original linear programming problem to be converted. \nThis problem can be a maximization or minimization problem.\nConstraints can be inequalities (≤, ≥) or equalities (=).\nVariables can have bounds (upper and lower), including negative lower bounds.\nverbose::Bool=false: Optional flag to enable detailed output during the conversion process. \nIf true, prints step-by-step information about the conversion, including:\nInitial problem details.\nConversion of maximization to minimization (if applicable).\nTransformation of inequalities into equalities.\nFinal problem details in standard form.\n\nReturns:\n\nA new LPProblem in standard form:\nThe objective function will be converted to a minimization problem.\nAll inequality constraints (≤, ≥) are converted to equalities by adding slack or surplus variables.\nVariables with negative lower bounds will be shifted to ensure non-negativity.\nSlack variables are introduced as new non-negative variables for each ≤ constraint, and surplus variables for each ≥ constraint.\n\nProcess:\n\nObjective Function: \nIf the original problem is a maximization problem, the objective function is negated to convert it into a minimization problem.\nConstraints: \nFor each ≤ constraint, a slack variable is added to convert it into an equality.\nFor each ≥ constraint, a surplus variable is added to convert it into an equality.\nAll equality constraints remain unchanged.\nVariables:\nVariables with negative lower bounds are shifted to ensure they are non-negative in the standard form.\nSlack and surplus variables are introduced and added to the constraint matrix.\n\nVerbose Output:\n\nIf verbose=true, the function will print:\n\nInitial problem details (objective function, constraints matrix, right-hand side, and constraint types).\nInformation on the conversion of a maximization problem to minimization (if applicable).\nDetails about the introduction of slack and surplus variables for each inequality constraint.\nThe final problem representation in standard form, including the new objective function, updated constraint matrix, and right-hand side.\n\nExample:\n\n# Original problem with 2 variables and 3 constraints\nlp = LPProblem(\n    false,  # Maximize\n    [3.0, 2.0],  # Objective function coefficients\n    sparse([1, 2, 1, 3], [1, 1, 2, 2], [1.0, 1.0, 1.0, 1.0], 3, 2),  # Constraint matrix\n    [4.0, 2.0, 3.0],  # Right-hand side\n    ['L', 'L', 'L'],  # Constraints: less-than-or-equal-to\n    [0.0, 0.0],  # Lower bounds\n    [Inf, Inf],  # Upper bounds\n    [\"x1\", \"x2\"],  # Variable names\n    [:Continuous, :Continuous]  # Variable types\n)\n\n# Convert to standard form\nstandard_lp = convert_to_standard_form(lp)\n\nIn the example, the original mazimization problem is converted to a minimization problem, whith slack varibles for each ≤ contraint to convert the problem into standard form.\n\n\n\n\n\n","category":"function"},{"location":"LpStandardFormConverter/","page":"LpStandardFormConverter","title":"LpStandardFormConverter","text":"This function transforms a given LPProblem into its standard form, which includes converting the objective function to a minimization problem, ensuring all constraints are inequalities, and handling variable bounds through additional constraints.","category":"page"},{"location":"LpStandardFormConverter/#Arguments","page":"LpStandardFormConverter","title":"Arguments","text":"","category":"section"},{"location":"LpStandardFormConverter/","page":"LpStandardFormConverter","title":"LpStandardFormConverter","text":"lp::LPProblem: A struct representing the Linear Programming problem, containing the objective function, constraints, and bounds.","category":"page"},{"location":"LpStandardFormConverter/#Returns","page":"LpStandardFormConverter","title":"Returns","text":"","category":"section"},{"location":"LpStandardFormConverter/","page":"LpStandardFormConverter","title":"LpStandardFormConverter","text":"new_A::SparseMatrixCSC: The transformed constraint matrix in standard form.\nnew_b::Vector{Float64}: The transformed right-hand side of the constraints.\nnew_c::Vector{Float64}: The transformed objective function coefficients.","category":"page"},{"location":"LpStandardFormConverter/#Method-Details","page":"LpStandardFormConverter","title":"Method Details","text":"","category":"section"},{"location":"LpStandardFormConverter/","page":"LpStandardFormConverter","title":"LpStandardFormConverter","text":"Handles lower and upper bounds for variables by adding additional constraints if necessary.\nEnsures all constraints are in the form of inequalities (either <= or >=).\nAdjusts the objective function to fit the standard form, which assumes a minimization problem.","category":"page"},{"location":"LpStandardFormConverter/#Usage-Example","page":"LpStandardFormConverter","title":"Usage Example","text":"","category":"section"},{"location":"LpStandardFormConverter/","page":"LpStandardFormConverter","title":"LpStandardFormConverter","text":"using lp_standard_form_converter\n\nlp = LPProblem(\n    is_minimize = false,  # Maximization problem\n    c = [2.0, 3.0],\n    A = sparse([1.0 1.0; 2.0 1.0]),\n    b = [5.0, 8.0],\n    l = [0.0, 0.0],\n    u = [Inf, Inf],\n    vars = [\"x1\", \"x2\"],\n    constraint_types = ['L', 'L']\n)\n\nnew_A, new_b, new_c = convert_to_standard_form(lp)\nprintln(\"New A: \", new_A)\nprintln(\"New b: \", new_b)\nprintln(\"New c: \", new_c)","category":"page"},{"location":"LpStandardFormConverter/","page":"LpStandardFormConverter","title":"LpStandardFormConverter","text":"","category":"page"},{"location":"LpStandardFormConverter/#Additional-Information","page":"LpStandardFormConverter","title":"Additional Information","text":"","category":"section"},{"location":"LpStandardFormConverter/","page":"LpStandardFormConverter","title":"LpStandardFormConverter","text":"Converting LP and MIP problems to standard form is essential for many solvers, as it ensures that the problem is in a form that the solver can handle efficiently.","category":"page"},{"location":"LpStandardFormConverter/","page":"LpStandardFormConverter","title":"LpStandardFormConverter","text":"","category":"page"},{"location":"LpStandardFormConverter/","page":"LpStandardFormConverter","title":"LpStandardFormConverter","text":"For any questions or contributions, please refer to the project's GitHub repository.","category":"page"},{"location":"LpReadMPS/#LpReadMPS-Module","page":"LpReadMPS","title":"LpReadMPS Module","text":"","category":"section"},{"location":"LpReadMPS/","page":"LpReadMPS","title":"LpReadMPS","text":"The LpReadMPS module provides functions for reading linear programming problems from MPS (Mathematical Programming System) files. ","category":"page"},{"location":"LpReadMPS/#Functions","page":"LpReadMPS","title":"Functions","text":"","category":"section"},{"location":"LpReadMPS/#read_file_to_string","page":"LpReadMPS","title":"read_file_to_string","text":"","category":"section"},{"location":"LpReadMPS/","page":"LpReadMPS","title":"LpReadMPS","text":"LpReadMPS.read_file_to_string","category":"page"},{"location":"LpReadMPS/#Main.LpReadMPS.read_file_to_string","page":"LpReadMPS","title":"Main.LpReadMPS.read_file_to_string","text":"read_file_to_string(file_path::String) -> String\n\nReads the contents of a file and returns it as a string.\n\nArguments\n\nfile_path::String: The path to the file.\n\nReturns\n\nString: The contents of the file as a string.\n\n\n\n\n\n","category":"function"},{"location":"LpReadMPS/","page":"LpReadMPS","title":"LpReadMPS","text":"Reads the contents of a file and returns it as a string. This is often used to read MPS files into a string format before parsing them into a problem structure.","category":"page"},{"location":"LpReadMPS/","page":"LpReadMPS","title":"LpReadMPS","text":"Usage Example:","category":"page"},{"location":"LpReadMPS/","page":"LpReadMPS","title":"LpReadMPS","text":"mps_string = read_file_to_string(\"path/to/file.mps\")","category":"page"},{"location":"LpReadMPS/#read_mps","page":"LpReadMPS","title":"read_mps","text":"","category":"section"},{"location":"LpReadMPS/","page":"LpReadMPS","title":"LpReadMPS","text":"LpReadMPS.read_mps","category":"page"},{"location":"LpReadMPS/#Main.LpReadMPS.read_mps","page":"LpReadMPS","title":"Main.LpReadMPS.read_mps","text":"read_mps(file_name::read_mps)\n\nReads an MPS file and converts it into an LPProblem struct.\n\nArguments\n\nfile_path::String: The path to the MPS file.\n\nReturns\n\nLPProblem: A struct containing the LP problem data.\n\n\n\n\n\n","category":"function"},{"location":"LpReadMPS/","page":"LpReadMPS","title":"LpReadMPS","text":"Reads an MPS problem from a file and converts it into an LPProblem struct.","category":"page"},{"location":"LpReadMPS/","page":"LpReadMPS","title":"LpReadMPS","text":"Usage Example:","category":"page"},{"location":"LpReadMPS/","page":"LpReadMPS","title":"LpReadMPS","text":"julia\nlp_problem = read_mps_from_file(\"path/to/file.mps\")","category":"page"},{"location":"LpReadMPS/#read_mps_from_string","page":"LpReadMPS","title":"read_mps_from_string","text":"","category":"section"},{"location":"LpReadMPS/","page":"LpReadMPS","title":"LpReadMPS","text":"LpReadMPS.read_mps_from_string","category":"page"},{"location":"LpReadMPS/#Main.LpReadMPS.read_mps_from_string","page":"LpReadMPS","title":"Main.LpReadMPS.read_mps_from_string","text":"read_mps_from_string(mps_string::String) -> LPProblem\n\nThis function parses a given MPS (Mathematical Programming System) formatted string and converts it into an LPProblem struct, representing a Linear Programming (LP) problem in Julia.\n\nArguments:\n\nmps_string::String: A string representing the content of an MPS file.\n\nReturns:\n\nLPProblem: A struct containing the LP problem data.\n\n\n\n\n\n","category":"function"},{"location":"LpReadMPS/#get_variable_type","page":"LpReadMPS","title":"get_variable_type","text":"","category":"section"},{"location":"LpReadMPS/","page":"LpReadMPS","title":"LpReadMPS","text":"LpReadMPS.get_variable_type","category":"page"},{"location":"LpReadMPS/#Main.LpReadMPS.get_variable_type","page":"LpReadMPS","title":"Main.LpReadMPS.get_variable_type","text":"get_variable_type(var) -> String\n\nDetermines the type of a variable in a mathematical optimization model.\n\nArguments\n\nvar: The variable whose type is to be determined. This is typically a variable from a mathematical optimization model, such as a JuMP variable.\n\nReturns\n\nString: The type of the variable as a string. Possible values are:\n\"Binary\": If the variable is binary (i.e., it can take values 0 or 1).\n\"Integer\": If the variable is an integer (i.e., it can take integer values).\n\"Continuous\": If the variable is continuous (i.e., it can take any real value).\n\nExample\n\nvar = @variable(model, Bin)\nprintln(get_variable_type(var))  # Outputs \"Binary\"\n\nThis function uses is_binary and is_integer to determine whether a variable is binary, integer, or continuous. \n\n\n\n\n\n","category":"function"},{"location":"LpReadMPS/#read_mps_with_JuMP","page":"LpReadMPS","title":"read_mps_with_JuMP","text":"","category":"section"},{"location":"LpReadMPS/","page":"LpReadMPS","title":"LpReadMPS","text":"LpReadMPS.read_mps_with_JuMP","category":"page"},{"location":"LpReadMPS/#Main.LpReadMPS.read_mps_with_JuMP","page":"LpReadMPS","title":"Main.LpReadMPS.read_mps_with_JuMP","text":"read_mps_with_JuMP(file_path::String) -> LPProblem\n\nReads an MPS file using JuMP and converts it into a LPProblem struct.\n\nArguments\n\nfile_path::String: The path to the MPS file.\n\nReturns\n\nLPProblem: A struct containing the MIP problem data.\n\n\n\n\n\n","category":"function"},{"location":"LpReadMPS/","page":"LpReadMPS","title":"LpReadMPS","text":"Reads a Linear Programming problem from an MPS file using JuMP and converts it into a LPProblem struct. This function relies on the JuMP and MathOptInterface packages for parsing and handling MIP problems.","category":"page"},{"location":"LpReadMPS/","page":"LpReadMPS","title":"LpReadMPS","text":"Usage Example:","category":"page"},{"location":"LpReadMPS/","page":"LpReadMPS","title":"LpReadMPS","text":"lp_problem = read_mps_with_JuMP(\"path/to/file.mps\")","category":"page"},{"location":"LpReadMPS/#Examples","page":"LpReadMPS","title":"Examples","text":"","category":"section"},{"location":"LpReadMPS/#Reading-an-LP-Problem-from-an-MPS-File","page":"LpReadMPS","title":"Reading an LP Problem from an MPS File","text":"","category":"section"},{"location":"LpReadMPS/","page":"LpReadMPS","title":"LpReadMPS","text":"lp_problem = read_mps(\"examples/test.mps\")\nprintln(lp_problem)","category":"page"},{"location":"LpReadMPS/#Additional-Information","page":"LpReadMPS","title":"Additional Information","text":"","category":"section"},{"location":"LpReadMPS/","page":"LpReadMPS","title":"LpReadMPS","text":"The lp_read_mps module provides tools for handling MPS files, which are commonly used in optimization tasks. These files encode linear and mixed integer programming problems in a standard format that can be parsed and processed by solvers.","category":"page"},{"location":"LpReadMPS/","page":"LpReadMPS","title":"LpReadMPS","text":"For more detailed information on the MPS format, refer to MPS documentation.","category":"page"},{"location":"LpReadLP/#LpReadLP-Module","page":"LpReadLP","title":"LpReadLP Module","text":"","category":"section"},{"location":"LpReadLP/","page":"LpReadLP","title":"LpReadLP","text":"The LpReadLP module provides functions for reading linear programming problems from CPLEX's LP file format.","category":"page"},{"location":"LpReadLP/#Functions","page":"LpReadLP","title":"Functions","text":"","category":"section"},{"location":"LpReadLP/#read_lp","page":"LpReadLP","title":"read_lp","text":"","category":"section"},{"location":"LpReadLP/","page":"LpReadLP","title":"LpReadLP","text":"LpReadLP.read_lp","category":"page"},{"location":"LpReadLP/#Main.LpReadLP.read_lp","page":"LpReadLP","title":"Main.LpReadLP.read_lp","text":"read_lp(filename::String) -> LPProblem\n\nReads a Linear Programming (LP) file in LP format and parses it into an LPProblem struct, which contains the objective function, constraints, bounds, and variable types.\n\nArguments:\n\nfilename::String: The name or path of the LP file to be read.\n\nReturns:\n\nLPProblem: A struct containing the parsed components of the LP problem:\nis_minimize::Bool: Indicates if the problem is a minimization (true) or maximization (false) problem.\nc::Vector{Float64}: Coefficients of the objective function.\nA::SparseMatrixCSC{Float64, Int64}: Constraint matrix in sparse format.\nb::Vector{Float64}: Right-hand side (RHS) values of the constraints.\nconstraint_types::Vector{Char}: A vector indicating the type of each constraint ('L' for <=, 'G' for >=, 'E' for =).\nl::Vector{Float64}: Lower bounds for the variables.\nu::Vector{Float64}: Upper bounds for the variables.\nvars::Vector{String}: Names of the variables used in the problem.\nvariable_types::Vector{Symbol}: Variable types (:Binary, :Integer, or :Continuous).\n\nSections handled in the LP file:\n\nObjective: Parses the objective function, whether it's \"Maximize\" or \"Minimize\". Coefficients and variables are parsed into a dictionary.\nConstraints: Parses constraints of the form x1 + 2 x2 <= 10, where coefficients and variables are stored in a sparse matrix format.\nBounds: Parses the variable bounds such as 0 <= x1 <= 100, or single-sided bounds like x2 <= 1.\nBinary and Integer: Handles binary and integer variable types.\nEnd: Stops parsing when the \"End\" keyword is encountered.\n\nRaises:\n\nErrorException: If parsing any term in the objective or constraints fails.\nErrorException: If a variable in the objective or constraints is not defined in the variable set.\n\nExample:\n\nlp = read_lp(\"example.lp\")\nprintln(lp.c)    # Objective function coefficients\nprintln(lp.A)    # Constraint matrix\nprintln(lp.b)    # Right-hand side of constraints\n\nNotes\n\nThe function assumes that the LP file is well-formed and adheres to the standard LP file format.\nThe contariants are stored in a sparse matrix for effient handling of large problems.\nVaribles without explicily defined bounds are assumend to have default bounds (-∞,∞).\n\n\n\n\n\n","category":"function"},{"location":"LpReadLP/#write_lp","page":"LpReadLP","title":"write_lp","text":"","category":"section"},{"location":"LpReadLP/","page":"LpReadLP","title":"LpReadLP","text":"LpReadLP.write_lp","category":"page"},{"location":"LpReadLP/#Main.LpReadLP.write_lp","page":"LpReadLP","title":"Main.LpReadLP.write_lp","text":"write_lp(filename::String, problem::LPProblem)\n\nWrites a linear programming (LP) problem to a file in the LP format, given an LPProblem struct.\n\nArguments:\n\nfilename::String: The name or path of the LP file to write.\nproblem::LPProblem: The linear programming problem to write. It contains fields for objective function, constraints, bounds, and variable types.\n\nWrites:\n\nAn LP file formatted with the following sections:\nObjective: The objective function (either \"Maximize\" or \"Minimize\").\nSubject To: The constraints on the variables, with appropriate relations (<=, >=, or =).\nBounds: The bounds for each variable, with \"free\" indicating no bounds.\nBinary and General: Specifies binary and integer variables, if any.\nEnd: Marks the end of the LP file.\n\nExample:\n\nlp = LPProblem(is_minimize, c, A_sparse, b, constraint_types, l, u, vars, variable_types_vec)\nwrite_lp(\"output.lp\", lp)\n\nNotes\n\nThe objective function coefficents are written in the standard LP format with signs and terms properly spaced.\nContraints are written based on the contraint matrix and right-hand side vector.\nBounds are written based on the contraint matrix and right-hand side vector.\nIf the problem contains binary of integer varibles, they are listed under the apporapiate sections.\n\n\n\n\n\n","category":"function"},{"location":"LpReadLP/#Further-Information","page":"LpReadLP","title":"Further Information","text":"","category":"section"},{"location":"LpReadLP/","page":"LpReadLP","title":"LpReadLP","text":"For specific information about LP files see either CPLEX or GUROBI's documentation. ","category":"page"},{"location":"LpProblem/#lLpProblem-Module","page":"LpProblem","title":"lLpProblem Module","text":"","category":"section"},{"location":"LpProblem/","page":"LpProblem","title":"LpProblem","text":"The LpProblem module defines data structures that represent linear programming (LP) and mixed integer programming (MIP) problems. It also provides a structure for handling preprocessed LP problems.","category":"page"},{"location":"LpProblem/#Structs","page":"LpProblem","title":"Structs","text":"","category":"section"},{"location":"LpProblem/#LPProblem","page":"LpProblem","title":"LPProblem","text":"","category":"section"},{"location":"LpProblem/","page":"LpProblem","title":"LpProblem","text":"LpProblem.LPProblem","category":"page"},{"location":"LpProblem/#Main.LpProblem.LPProblem","page":"LpProblem","title":"Main.LpProblem.LPProblem","text":"struct LPProblem\n\nRepresents a linear programming (LP) or mixed integer programming (MIP) problem.\n\nFields:\n\nis_minimize::Bool: True if the objective is to minimize, False for maximization problems.\nc::Vector{Float64}: Coefficients of the objective function (c^T * X).\nA::SparseMatrixCSC{Float64, Int64}: Constraint matrix (A in AX = b).\nb::Vector{Float64}: Right-hand side of constraints (b in AX = b).\nconstraint_types::Vector{Char}: Types of constraints ('L' for ≤, 'G' for ≥, 'E' for =).\nl::Vector{Float64}: Lower bounds for variables (l in l ≤ X).\nu::Vector{Float64}: Upper bounds for variables (u in X ≤ u).\nvars::Vector{String}: Names of variables (e.g., [\"x1\", \"x2\", \"x3\"]).\nvariable_types::Vector{Symbol}: Types of variables (e.g., :Continuous, :Integer, :Binary).\n\nExample:\n\nlp = LPProblem(\n    is_minimize = false,  # Maximization problem\n    c = [3.0, 5.0, 7.0],  # Coefficients for the objective function\n    A = sparse([1.0, 2.0, 3.0; 4.0, 5.0, 6.0]),  # Constraint matrix\n    b = [10.0, 20.0],  # Right-hand side of constraints\n    constraint_types = ['L', 'L'],  # Less than or equal constraints\n    l = [0.0, 0.0, 0.0],  # Lower bounds for variables\n    u = [Inf, Inf, 1.0],  # Upper bounds (third variable is binary)\n    vars = [\"x1\", \"x2\", \"x3\"],  # Variable names\n    variable_types = [:Continuous, :Integer, :Binary]  # Types of variables\n)\n\n\n\n\n\n","category":"type"},{"location":"LpProblem/#PreprocessedLPProblem","page":"LpProblem","title":"PreprocessedLPProblem","text":"","category":"section"},{"location":"LpProblem/","page":"LpProblem","title":"LpProblem","text":"LpProblem.PreprocessedLPProblem","category":"page"},{"location":"LpProblem/#Main.LpProblem.PreprocessedLPProblem","page":"LpProblem","title":"Main.LpProblem.PreprocessedLPProblem","text":"struct PreprocessedLPProblem\n\nRepresents a linear programming (LP) or mixed integer programming (MIP) problem after preprocessing steps.\n\nFields:\n\noriginal_problem::LPProblem: The original problem before any preprocessing.\nreduced_problem::LPProblem: The problem after preprocessing steps, such as removing fixed variables or redundant constraints.\nremoved_rows::Vector{Int}: Indices of the rows that were removed during preprocessing (e.g., redundant constraints).\nremoved_cols::Vector{Int}: Indices of the columns (variables) that were removed during preprocessing (e.g., fixed or dominated variables).\nrow_ratios::Dict{Int, Tuple{Int, Float64}}: Stores information about row reductions, where the key is the row index, and the value is a tuple containing the original row index and a ratio used during row elimination.\nvar_solutions::Dict{String, Float64}: A dictionary mapping the names of removed variables to their fixed values during preprocessing (e.g., variables fixed due to bounds or presolve procedures).\nrow_scaling::Vector{Float64}: Scaling factors applied to the rows (optional, if scaling was used for numerical stability).\ncol_scaling::Vector{Float64}: Scaling factors applied to the columns (optional, if scaling was used for numerical stability).\nis_infeasible::Bool: A flag indicating whether the problem was detected as infeasible during preprocessing.\n\nExample:\n\npreprocessed_lp = PreprocessedLPProblem(\n    original_problem = lp,  # The original LP or MIP problem\n    reduced_problem = reduced_lp,  # The reduced problem after preprocessing\n    removed_rows = [2, 5],  # Rows that were removed\n    removed_cols = [1, 3],  # Columns (variables) that were removed\n    row_ratios = Dict(5 => (2, 0.5)),  # Ratio for row 5 being reduced from row 2\n    var_solutions = Dict(\"x1\" => 1.0, \"x3\" => 2.0),  # Solution values for removed variables\n    row_scaling = [1.0, 0.5, 0.25],  # Scaling factors for rows\n    col_scaling = [1.0, 2.0, 0.75],  # Scaling factors for columns\n    is_infeasible = false  # No infeasibility detected\n)\n\n\n\n\n\n","category":"type"},{"location":"LpProblem/#Examples","page":"LpProblem","title":"Examples","text":"","category":"section"},{"location":"LpProblem/#Creating-an-LP-Problem","page":"LpProblem","title":"Creating an LP Problem","text":"","category":"section"},{"location":"LpProblem/","page":"LpProblem","title":"LpProblem","text":"To create a linear programming problem using the LPProblem struct:","category":"page"},{"location":"LpProblem/","page":"LpProblem","title":"LpProblem","text":"using lp_problem\n\nc = [1.0, 2.0, 3.0]\nA = sparse([1.0, 0.0, 0.0, 1.0, 1.0, 1.0], 2, 3)\nb = [4.0, 6.0]\nl = [0.0, 0.0, 0.0]\nu = [10.0, 10.0, 10.0]\nvars = [\"x1\", \"x2\", \"x3\"]\nconstraint_types = ['L', 'L']\n\nlp = LPProblem(true, c, A, b, l, u, vars, constraint_types)","category":"page"},{"location":"#Project-Documentation","page":"Home","title":"Project Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for this project, which provides tools and utilities for solving linear programming (LP) and mixed integer programming (MIP) problems in julia. The project is organized into different modules, each focusing on specific aspects of problem-solving, including preprocessing, problem formulation, and solution techniques.","category":"page"},{"location":"#Modules","page":"Home","title":"Modules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LpPresolve: This module provides functions for preprocessing LP problems, such as removing zero rows, zero columns, and linearly dependent rows.\nLpProblem: This module defines the data structures for representing LP and MIP problems, including the LPProblem and PreprocessedLPProblem structs.\nLpReadMPS: This module contains functions for reading linear programming (LP) problems from MPS (Mathematical Programming System) files. It supports reading from both file and string formats.\nLpRevisedSimplex: This module implements the revised simplex method for solving LP problems. It handles problem conversion to standard form, iteration over basis variables, and optimization checks.\nLpStandardFormConverter: This module provides functions for converting LP and MIP problems into their standard forms, including handling constraints and slack variables.\njuLinear: This module implements a commandline inteface for this linear program solver.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To begin using the tools in this project, follow these steps:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Install the required dependencies: You will need to install Julia and any required packages for this project (e.g., SparseArrays, JuMP, Documenter).\nExplore the Modules: Visit the module pages linked above to learn more about the functions and data structures provided by each module.\nExamples: Each module page provides examples on how to create LP/MIP problems, preprocess them, and solve them.","category":"page"},{"location":"#About-the-Project","page":"Home","title":"About the Project","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project focuses on solving optimization problems using linear programming and mixed integer programming techniques. It includes modules that help preprocess problems, formulate them, and solve them using various methods such as the revised simplex algorithm and MPS file readers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more detailed information, explore the individual modules and example usage.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"For any questions or contributions, please refer to the project's GitHub repository.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is a code repository of HARD software ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: HARDsoftware)","category":"page"},{"location":"LpPresolve/#LpPresolve-Module","page":"LpPresolve","title":"LpPresolve Module","text":"","category":"section"},{"location":"LpPresolve/","page":"LpPresolve","title":"LpPresolve","text":"The LpPresolve module provides several utility functions for preprocessing linear programming problems by removing redundant rows, columns, and detecting linearly dependent constraints.","category":"page"},{"location":"LpPresolve/#Functions","page":"LpPresolve","title":"Functions","text":"","category":"section"},{"location":"LpPresolve/#lp_remove_zero_rows","page":"LpPresolve","title":"lp_remove_zero_rows","text":"","category":"section"},{"location":"LpPresolve/","page":"LpPresolve","title":"LpPresolve","text":"LpPresolve.lp_remove_zero_rows","category":"page"},{"location":"LpPresolve/#Main.LpPresolve.lp_remove_zero_rows","page":"LpPresolve","title":"Main.LpPresolve.lp_remove_zero_rows","text":"lpremovezerorows(preprocessedproblem::PreprocessedLPProblem; ε::Float64 = 1e-8, verbose::Bool = false)\n\nRemoves zero rows (constraints) from the LP problem where all coefficients are approximately zero. This simplifies the problem by eliminating redundant constraints that do not affect the feasible region.\n\nParameters\n\npreprocessed_problem::PreprocessedLPProblem: The LP or MIP problem to process.\nε::Float64 = 1e-8: Tolerance used to determine if a coefficient is considered zero.\nverbose::Bool = false: If true, prints detailed debug information during processing.\n\nReturns\n\nPreprocessedLPProblem: A new PreprocessedLPProblem instance with:\nreduced_problem: Updated by removing zero rows.\nremoved_rows: Updated to include indices of the removed rows.\nis_infeasible: Set to true if an infeasibility is detected due to a zero row with a conflicting right-hand side.\n\nBehavior\n\nZero Row Detection: Identifies constraints where all coefficients in A are approximately zero within the tolerance ε.\nInfeasibility Check: For zero rows corresponding to equality constraints with a non-zero right-hand side (b), the problem is marked as infeasible.\nProblem Reduction: Creates a new reduced_problem without the zero rows, adjusting:\nConstraint matrix (A).\nRight-hand side vector (b).\nConstraint types (constraint_types).\nVariables Unchanged: Variable-related data (c, l, u, vars, variable_types) remain unchanged.\n\nExamples\n\nusing SparseArrays\n\n# Define the original LP problem\nc = [1.0, 2.0]  # Objective function coefficients\nA = sparse([0.0 0.0; 1.0 -1.0])  # Constraint matrix with a zero row\nb = [0.0, 5.0]  # Right-hand side vector\nl = [0.0, 0.0]  # Lower bounds\nu = [Inf, Inf]  # Upper bounds\nvars = [\"x1\", \"x2\"]  # Variable names\nconstraint_types = ['E', 'L']  # Constraint types ('E' for =, 'L' for ≤)\nvariable_types = [:continuous, :continuous]  # Variable types\n\n# Create the original LPProblem\noriginal_lp = LPProblem(\n    is_minimize = true,\n    c = c,\n    A = A,\n    b = b,\n    constraint_types = constraint_types,\n    l = l,\n    u = u,\n    vars = vars,\n    variable_types = variable_types\n)\n\n# Initialize the PreprocessedLPProblem\nlp_model = PreprocessedLPProblem(\n    original_problem = original_lp,\n    reduced_problem = original_lp,  # Initially the same as the original\n    removed_rows = Int[],           # No rows removed yet\n    removed_cols = Int[],           # No columns removed yet\n    row_ratios = Dict{Int, Tuple{Int, Float64}}(),  # No row reductions yet\n    var_solutions = Dict{String, Float64}(),        # Variable solutions not yet filled\n    row_scaling = Float64[],                        # No row scaling applied\n    col_scaling = Float64[],                        # No column scaling applied\n    is_infeasible = false                           # Problem is feasible initially\n)\n\n# Remove zero rows\nnew_lp_model = lp_remove_zero_rows(lp_model; verbose = true)\n\n# Output the reduced problem\nprintln(\"Reduced Problem after removing zero rows:\")\nprintln(new_lp_model.reduced_problem)\n\n# Check for infeasibility\nif new_lp_model.is_infeasible\n    println(\"The problem is infeasible due to a zero row with a conflicting RHS.\")\nelse\n    println(\"Zero rows successfully removed.\")\nend\n\nNotes\n\nInfeasibility Detection: If a zero row corresponds to an equality constraint with a non-zero right-hand side, the problem is infeasible.\nSparse Matrix Efficiency: The function leverages sparse matrix properties for efficient computation.\nIntegration: This function can be used as part of a presolve routine to simplify LP/MIP problems before optimization.\n\nSee Also\n\nlp_detect_and_remove_fixed_variables\nlp_detect_and_remove_row_singletons\nlp_detect_and_remove_column_singletons\n\n\n\n\n\n","category":"function"},{"location":"LpPresolve/#lp_remove_row_singletons","page":"LpPresolve","title":"lp_remove_row_singletons","text":"","category":"section"},{"location":"LpPresolve/","page":"LpPresolve","title":"LpPresolve","text":"LpPresolve.lp_remove_row_singletons","category":"page"},{"location":"LpPresolve/#Main.LpPresolve.lp_remove_row_singletons","page":"LpPresolve","title":"Main.LpPresolve.lp_remove_row_singletons","text":"lpremoverowsingletons(lpmodel::PreprocessedLPProblem; ε::Float64 = 1e-8, verbose::Bool = false)\n\nIdentifies and processes row singletons in an LP or MIP problem. A row singleton is a constraint involving only one variable. The function adjusts variable bounds or fixes variables as appropriate, simplifies the problem, and updates the PreprocessedLPProblem struct.\n\nParameters\n\nlp_model::PreprocessedLPProblem: The preprocessed LP or MIP problem before processing row singletons.\nε::Float64 = 1e-8: Tolerance used to handle numerical precision issues.\nverbose::Bool = false: If true, prints detailed debug information during processing.\n\nReturns\n\nPreprocessedLPProblem: A new PreprocessedLPProblem instance with:\nreduced_problem: Updated by processing row singletons.\nremoved_rows: Updated with indices of the removed singleton rows.\nremoved_cols: Updated with indices of variables removed (if any).\nvar_solutions: Updated with values of any variables fixed during processing.\nis_infeasible: Set to true if an infeasibility is detected.\n\nBehavior\n\nRow Singleton Detection: Identifies constraints involving only one variable.\nProcessing:\nFor equality constraints ('E'):\nSolves for the variable and fixes its value.\nRemoves the variable and the constraint from the problem.\nFor less-than-or-equal constraints ('L'):\nAdjusts the variable's upper or lower bound depending on the coefficient.\nRemoves the constraint from the problem.\nFor greater-than-or-equal constraints ('G'):\nAdjusts the variable's lower or upper bound depending on the coefficient.\nRemoves the constraint from the problem.\nInfeasibility Check: If variable bounds become inconsistent after processing, the problem is marked as infeasible.\nProblem Reduction: Updates the constraint matrix, right-hand side vector, variable bounds, objective function, and removes processed variables and constraints.\n\nExamples\n\nusing SparseArrays\n\n# Define the original LP problem\nc = [2.0, 3.0, 1.0]\nA = sparse([\n    1.0  0.0  0.0;  # Singleton row involving x1\n    0.0  1.0  1.0;\n    0.0  0.0  1.0   # Singleton row involving x3\n])\nb = [5.0, 10.0, 3.0]\nl = [0.0, 0.0, 0.0]\nu = [Inf, Inf, Inf]\nvars = [\"x1\", \"x2\", \"x3\"]\nconstraint_types = ['E', 'L', 'E']\nvariable_types = [:continuous, :continuous, :continuous]\n\n# Create the original LPProblem\noriginal_lp = LPProblem(\n    is_minimize = true,\n    c = c,\n    A = A,\n    b = b,\n    constraint_types = constraint_types,\n    l = l,\n    u = u,\n    vars = vars,\n    variable_types = variable_types\n)\n\n# Initialize the PreprocessedLPProblem\nlp_model = PreprocessedLPProblem(\n    original_problem = original_lp,\n    reduced_problem = original_lp,  # Initially the same as the original\n    removed_rows = Int[],           # No rows removed yet\n    removed_cols = Int[],           # No columns removed yet\n    row_ratios = Dict{Int, Tuple{Int, Float64}}(),  # No row reductions yet\n    var_solutions = Dict{String, Float64}(),        # Variable solutions not yet filled\n    row_scaling = Float64[],                        # No row scaling applied\n    col_scaling = Float64[],                        # No column scaling applied\n    is_infeasible = false                           # Problem is feasible initially\n)\n\n# Process row singletons\nnew_lp_model = lp_remove_row_singletons(lp_model; verbose = true)\n\n# Output the reduced problem\nprintln(\"Reduced Problem after processing row singletons:\")\nprintln(new_lp_model.reduced_problem)\n\n# Output fixed variable solutions\nprintln(\"Fixed Variable Solutions:\")\nprintln(new_lp_model.var_solutions)\n\nNotes\n\nInfeasibility Detection: If variable bounds conflict after processing, the problem is marked as infeasible.\nVariable Removal: Variables fixed during processing are removed from the problem.\nIntegration: This function is part of a presolve routine to simplify LP/MIP problems before optimization.\n\nSee Also\n\nlp_detect_and_remove_fixed_variables\nlp_remove_zero_rows\nlp_detect_and_remove_column_singletons\n\n\n\n\n\n","category":"function"},{"location":"LpPresolve/#lp_detect_and_remove_fixed_varibles","page":"LpPresolve","title":"lp_detect_and_remove_fixed_varibles","text":"","category":"section"},{"location":"LpPresolve/","page":"LpPresolve","title":"LpPresolve","text":"LpPresolve.lp_detect_and_remove_fixed_variables","category":"page"},{"location":"LpPresolve/#Main.LpPresolve.lp_detect_and_remove_fixed_variables","page":"LpPresolve","title":"Main.LpPresolve.lp_detect_and_remove_fixed_variables","text":"lpdetectandremovefixedvariables(lpmodel::PreprocessedLPProblem; ε::Float64 = 1e-8, verbose::Bool = false)\n\nDetects and removes fixed variables from an LP or MIP problem within a presolve module. A variable is considered fixed if its lower and upper bounds are approximately equal within a specified tolerance. The function removes these variables from the reduced problem and stores their values for the postsolve phase.\n\nParameters\n\nlp_model::PreprocessedLPProblem: The preprocessed LP or MIP problem before fixed variable removal.\nε::Float64 = 1e-8: Tolerance used to determine if a variable is fixed (i.e., when |l[i] - u[i]| < ε).\nverbose::Bool = false: If true, prints detailed debug information during processing.\n\nReturns\n\nPreprocessedLPProblem: A new PreprocessedLPProblem instance with:\nreduced_problem: Updated by removing fixed variables and adjusting related data structures.\nvar_solutions: Updated with the fixed variable values for the postsolve phase.\nremoved_cols: Updated to include indices of the removed (fixed) variables.\nOther fields (removed_rows, row_ratios, row_scaling, col_scaling, is_infeasible) remain unchanged unless affected by this operation.\n\nBehavior\n\nFixed Variable Detection: Identifies variables where |l[i] - u[i]| < ε and considers them fixed.\nVariable Solutions Storage: Stores the values of fixed variables in var_solutions.\nProblem Reduction: Creates a new reduced_problem without the fixed variables, adjusting:\nObjective function coefficients (c).\nConstraint matrix (A).\nRight-hand side vector (b).\nVariable bounds (l and u).\nVariable names (vars) and types (variable_types).\nConstraint Adjustment: Subtracts the contributions of fixed variables from the right-hand side of constraints.\n\nExamples\n\nusing SparseArrays\n\n# Define the original LP problem\nc = [1.0, 2.0, 4.0]  # Objective function coefficients\nA = sparse([1.0 -3.0 0.0; 2.0 1.0 -5.0])  # Constraint matrix\nb = [10.0, 15.0]  # Right-hand side vector\nl = [12.0, 0.0, 2.0]  # Lower bounds (x1 and x3 are fixed)\nu = [12.0, 1.0, 2.0]  # Upper bounds\nvars = [\"x1\", \"x2\", \"x3\"]  # Variable names\nconstraint_types = ['L', 'L']  # Constraint types ('L' for ≤)\nvariable_types = [:continuous, :continuous, :continuous]  # Variable types\n\n# Create the original LPProblem\noriginal_lp = LPProblem(\n    is_minimize = false,\n    c = c,\n    A = A,\n    b = b,\n    constraint_types = constraint_types,\n    l = l,\n    u = u,\n    vars = vars,\n    variable_types = variable_types\n)\n\n# Initialize the PreprocessedLPProblem\nlp_model = PreprocessedLPProblem(\n    original_problem = original_lp,\n    reduced_problem = original_lp,  # Initially the same as the original\n    removed_rows = Int[],           # No rows removed yet\n    removed_cols = Int[],           # No columns removed yet\n    row_ratios = Dict{Int, Tuple{Int, Float64}}(),  # No row reductions yet\n    var_solutions = Dict{String, Float64}(),        # Variable solutions not yet filled\n    row_scaling = Float64[],                        # No row scaling applied\n    col_scaling = Float64[],                        # No column scaling applied\n    is_infeasible = false                           # Problem is feasible initially\n)\n\n# Detect and remove fixed variables\nnew_lp_model = lp_detect_and_remove_fixed_variables(lp_model; verbose = true)\n\n# Output the reduced problem\nprintln(\"Reduced Problem after fixed variable removal:\")\nprintln(new_lp_model.reduced_problem)\n\n# Output the fixed variable solutions\nprintln(\"Fixed Variable Solutions:\")\nprintln(new_lp_model.var_solutions)\n\nNotes\n\nIn-Place Modification: This function does not modify lp_model in place; it returns a new instance with updated fields.\nInfeasibility Check: If removing fixed variables leads to an infeasible problem, the is_infeasible flag is set to true.\nIntegration: This function is typically used as part of a sequence of presolve operations to simplify LP/MIP problems before optimization.\n\nSee Also\n\nlp_detect_and_remove_row_singletons\nlp_detect_and_remove_column_singletons\nlp_bound_tightening\n\n\n\n\n\n","category":"function"},{"location":"LpPresolve/#lp_remove_zero_columns","page":"LpPresolve","title":"lp_remove_zero_columns","text":"","category":"section"},{"location":"LpPresolve/","page":"LpPresolve","title":"LpPresolve","text":"LpPresolve.lp_remove_zero_columns","category":"page"},{"location":"LpPresolve/#Main.LpPresolve.lp_remove_zero_columns","page":"LpPresolve","title":"Main.LpPresolve.lp_remove_zero_columns","text":"lp_remove_zero_columns(preprocessed_lp::PreprocessedLPProblem; ε::Float64=1e-8, verbose::Bool=false)\n\nRemoves variables corresponding to zero columns in the constraint matrix A from an LP or MIP problem. Variables that do not appear in any constraints are analyzed and set to values that optimize the objective function or satisfy bounds. The function updates the PreprocessedLPProblem accordingly.\n\nParameters\n\npreprocessed_lp::PreprocessedLPProblem: The preprocessed LP or MIP problem before zero column removal.\nε::Float64=1e-8: Tolerance used to determine if a coefficient is considered zero.\nverbose::Bool=false: If true, prints detailed debug information during processing.\n\nReturns\n\nPreprocessedLPProblem: A new PreprocessedLPProblem instance with:\nreduced_problem: Updated by removing zero columns and adjusting variable values.\nremoved_cols: Updated to include indices of the removed columns (variables).\nvar_solutions: Updated with the values of variables corresponding to zero columns.\nis_infeasible: Set to true if an infeasibility is detected due to unbounded variables.\n\nBehavior\n\nZero Column Detection: Identifies variables (columns) where all coefficients in A are approximately zero within the tolerance ε.\nVariable Processing:\nFor each zero column variable, determines its value based on:\nObjective function coefficient (c[j]).\nVariable bounds (l[j] and u[j]).\nProblem type (minimization or maximization).\nUpdates var_solutions with the variable's value.\nRemoves the variable from the problem.\nInfeasibility Check: If a variable can improve the objective unboundedly and is unbounded in that direction, the problem is marked as infeasible.\nProblem Reduction: Updates the constraint matrix A, objective coefficients c, variable bounds, and other relevant data structures by removing zero columns.\n\nExamples\n\nusing SparseArrays\n\n# Define the original LP problem\nc = [1.0, -2.0, 0.0]  # Objective function coefficients\nA = sparse([1.0 2.0 0.0; 0.0 -1.0 0.0])  # Constraint matrix (third column is zero)\nb = [4.0, -1.0]  # Right-hand side\nl = [0.0, 0.0, 0.0]  # Lower bounds\nu = [Inf, Inf, Inf]  # Upper bounds\nvars = [\"x1\", \"x2\", \"x3\"]  # Variable names\nconstraint_types = ['L', 'G']  # Constraint types\nvariable_types = [:continuous, :continuous, :continuous]  # Variable types\n\n# Create the original LPProblem\noriginal_lp = LPProblem(\n    is_minimize = true,\n    c = c,\n    A = A,\n    b = b,\n    constraint_types = constraint_types,\n    l = l,\n    u = u,\n    vars = vars,\n    variable_types = variable_types\n)\n\n# Initialize the PreprocessedLPProblem\npreprocessed_lp = PreprocessedLPProblem(\n    original_problem = original_lp,\n    reduced_problem = original_lp,\n    removed_rows = Int[],\n    removed_cols = Int[],\n    row_ratios = Dict{Int, Tuple{Int, Float64}}(),\n    var_solutions = Dict{String, Float64}(),\n    row_scaling = Float64[],\n    col_scaling = Float64[],\n    is_infeasible = false\n)\n\n# Remove zero columns\nnew_preprocessed_lp = lp_remove_zero_columns(preprocessed_lp; verbose = true)\n\n# Output the reduced problem\nprintln(\"Reduced Problem after removing zero columns:\")\nprintln(new_preprocessed_lp.reduced_problem)\n\n# Output variable solutions\nprintln(\"Variable solutions:\")\nprintln(new_preprocessed_lp.var_solutions)\n\nNotes\n\nUnbounded Variables: Variables with zero columns and unbounded in the direction of improving the objective function can lead to unboundedness. The problem is marked as infeasible in such cases.\nIntegration: This function is typically used as part of a sequence of presolve operations to simplify LP/MIP problems before optimization.\nVariable Removal: Variables corresponding to zero columns are removed from the problem and their values are stored in var_solutions.\n\nSee Also\n\nlp_detect_and_remove_fixed_variables\nlp_remove_zero_rows\nlp_remove_row_singletons\nlp_detect_and_remove_column_singletons\n\n\n\n\n\n","category":"function"},{"location":"LpPresolve/#lp_remove_linearly_dependent_rows","page":"LpPresolve","title":"lp_remove_linearly_dependent_rows","text":"","category":"section"},{"location":"LpPresolve/","page":"LpPresolve","title":"LpPresolve","text":"LpPresolve.lp_remove_linearly_dependent_rows","category":"page"},{"location":"LpPresolve/#Main.LpPresolve.lp_remove_linearly_dependent_rows","page":"LpPresolve","title":"Main.LpPresolve.lp_remove_linearly_dependent_rows","text":"lp_remove_linearly_dependent_rows(preprocessed_lp::PreprocessedLPProblem; ε::Float64=1e-8, verbose::Bool=false)\n\nRemoves linearly dependent rows from the constraint matrix A of the PreprocessedLPProblem. Detects and eliminates rows that are linear combinations of other rows.\n\nArguments:\n\npreprocessed_lp: The PreprocessedLPProblem struct containing the original and reduced problem.\nε: Threshold below which values are considered zero. Defaults to 1e-8.\nverbose: If true, prints debugging information. Defaults to false.\n\nReturns:\n\nA new PreprocessedLPProblem with linearly dependent rows removed.\n\n\n\n\n\n","category":"function"},{"location":"LpPresolve/#presolve_lp","page":"LpPresolve","title":"presolve_lp","text":"","category":"section"},{"location":"LpPresolve/","page":"LpPresolve","title":"LpPresolve","text":"LpPresolve.presolve_lp","category":"page"},{"location":"LpPresolve/#Main.LpPresolve.presolve_lp","page":"LpPresolve","title":"Main.LpPresolve.presolve_lp","text":"presolve_lp(lp_problem::LPProblem; verbose::Bool=false)\n\nApplies presolve routines to the given LPProblem to reduce the problem size by removing redundant rows and columns.\n\nArguments:\n\nlp_problem: The LPProblem to be presolved.\nverbose: If true, prints debugging information for each presolve step. Defaults to false.\n\nReturns:\n\nA PreprocessedLPProblem with a reduced problem that excludes zero rows, zero columns, singleton rows, and linearly dependent rows.\n\n\n\n\n\n","category":"function"},{"location":"LpPresolve/#Examples","page":"LpPresolve","title":"Examples","text":"","category":"section"},{"location":"LpPresolve/","page":"LpPresolve","title":"LpPresolve","text":"Here’s an example of how to use the lp_presolve module:","category":"page"},{"location":"LpPresolve/","page":"LpPresolve","title":"LpPresolve","text":"using lp_presolve\n\n# Create an LP problem (lp_problem)\npreprocessed_lp = presolve_lp(lp_problem, debug=true)\n\n# Check the results after presolve\nprintln(\"Preprocessed Problem: \", preprocessed_lp)","category":"page"}]
}
